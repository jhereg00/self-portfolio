{"version":3,"sources":["../../node_modules/browser-pack/_prelude.js","lib/animateScrollTo.js","scripts.min.js","lib/breakpoints.js","lib/ease.js","lib/getPageOffset.js","lib/getScrollPos.js","lib/getWindowSize.js","lib/loop.js","lib/scrollController.js","lib/setTransform.js","objects/article.js","objects/footer.js","objects/halftone.js","objects/illustration.js","objects/myTitles.js","objects/scrollOnLoad.js","scripts.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","animTime","startTime","startPos","endPos","loop","getPageOffset","getScrollPos","eases","defaultOffsetTop","defaultAnimTime","animFn","now","Date","getTime","window","scrollTo","easeInOut","removeFunction","dest","scrollPos","anim","time","offset","document","getElementById","replace","top","isNaN","err","addFunction","lib/ease","lib/getPageOffset","lib/getScrollPos","lib/loop",2,"bps","windowSize","getBreakpoint","size","width","lib/getWindowSize",3,"c","p","easeIn","easeInCubic","easeOut","easeOutCubic","linear",4,"element","pageOffsetX","offsetLeft","pageOffsetY","offsetTop","offsetParent","left",5,"undefined","scrollY","documentElement","scrollTop",6,"windowHeight","innerHeight","clientHeight","windowWidth","innerWidth","clientWidth","height",7,"requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","callback","setTimeout","loopFn","running","currentTime","currentScroll","body","offsetWidth","lastBodyWidth","offsetHeight","lastBodyHeight","resizeTimeout","clearTimeout","doLoopFunctions","resizeDebounce","lastScroll","lastTime","loopFuncs","resize","scroll","tick","addLoopFunction","type","fn","indexOf","push","start","addScrollFunction","addResizeFunction","types","found","index","splice","stop","len","force",8,"Parallax","onScroll","this","_this","measure","getPercentage","onResize","apply","enable","prototype","po","bottom","perc","disable","destroy",9,"transformAttributes","setTransform","transformString","style",10,"Halftone","ScrollController","HEADER_HALFTONE_SETTINGS","fade","inEaseStart","INNER_HALFTONE_SETTINGS","imageSizing","inEaseEnd","outEaseStart","cornering","maxRadius","RELATED_HALFTONE_SETTINGS","inEaseFn","outEaseEnd","Article","headerEl","querySelector","header","halftoneEls","querySelectorAll","halftones","ht","relatedsEl","scrollController","isPast","fixScroll","newScrollPos","remove","articleEl","lib/breakpoints","lib/scrollController","objects/halftone",11,"footerHalftoneEl",12,"DEFAULTS","outEaseFn","fixed","control","fill","initialDrawPercentage","minBreakpoint","BREAKPOINT_FOR_SCROLL_CONTROL","Dot","gridX","gridY","parent","radius","percentage","columns","rows","x","settings","y","draw","ctx","moveTo","arc","Math","PI","setRadiusByPercentage","percent","max","min","dotSizeImage","prop","Image","src","onload","sizeDotsByImage","lastDrawnPercentage","getPercentageFromScroll","computedStyle","getComputedStyle","position","backgroundColor","backgroundImage","image","match","background","createCanvas","init","round","canvas","clearRect","save","beginPath","effectiveInPerc","effectiveOutPerc","dots","dotInPerc","dotOutPerc","imageOffsets","globalCompositeOperation","drawImage","restore","enableCanvas","lastCanvas","createElement","setAttribute","floor","getContext","fillStyle","rad","children","insertBefore","appendChild","complete","sizeImage","scale","dotsImageOffsets","tempCan","tempCanCtx","fillRect","imgData","getImageData","averageRed","j","jLen","data","opacityAdd","startPerc","endPerc","ease","cb","deltaPerc","animationFn","deltaTime","animIn","animOut","lib/setTransform",13,"ILLUSTRATION_HALFTONE_SETTINGS","Illustration","halftone","illustrationEls",14,"HALFTONE_SETTINGS","ANIM_TIME","MyTitles","animNext","setInterval","myTitlesEls",15,"animateScrollTo","headerMain","pageType","getAttribute","sessionStorage","getItem","setItem","lib/animateScrollTo",16,"objects/article","objects/footer","objects/illustration","objects/myTitles","objects/scrollOnLoad"],"mappings":"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","file":"scripts.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n *  Animates window scroll to an element or scrollY\n */\n\n// requirements\nvar loop = require('lib/loop');\nvar getPageOffset = require('lib/getPageOffset');\nvar getScrollPos = require('lib/getScrollPos');\nvar eases = require('lib/ease');\n\n// settings\nvar defaultOffsetTop = 48;\nvar defaultAnimTime = 1000;\nvar animTime;\n\n// do things!\n/**\n *  the function that goes in the loop\n */\nvar startTime, startPos, endPos;\nvar animFn = function () {\n  var now = new Date().getTime();\n  if (now - startTime < animTime)\n    window.scrollTo(0, eases.easeInOut(startPos, endPos - startPos, (now - startTime) / animTime));\n  else {\n    window.scrollTo(0, endPos);\n    loop.removeFunction(animFn);\n  }\n}\n\n/**\n *  Scroll to element or number\n *  @param {HTMLElement or string(id of element) or number}\n *  [@param {number}] position to start scrolling from\n *  [@param {boolean}] pass false to skip animation\n *  [@param {number}] time for animation\n *  [@param {number}] offset from top\n */\nvar scrollTo = function (dest, scrollPos, anim, time, offset) {\n  if (typeof dest === 'string') {\n    dest = document.getElementById(dest.replace('#',''));\n  }\n  if (typeof dest !== 'number') {\n    try {\n      dest = getPageOffset(dest).top - (isNaN(offset) ? defaultOffsetTop : offset);\n    } catch (err) {\n      return false;\n    }\n  }\n\n  loop.removeFunction(animFn);\n  if (anim !== false) {\n    startPos = scrollPos || getScrollPos();\n    endPos = dest;\n    startTime = new Date().getTime();\n    animTime = time || defaultAnimTime;\n\n    loop.addFunction(animFn);\n  }\n  else {\n    window.scrollTo(0, dest);\n  }\n\n  return true;\n}\n\nmodule.exports = scrollTo;\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n *  Animates window scroll to an element or scrollY\n */\n\n// requirements\nvar loop = require('lib/loop');\nvar getPageOffset = require('lib/getPageOffset');\nvar getScrollPos = require('lib/getScrollPos');\nvar eases = require('lib/ease');\n\n// settings\nvar defaultOffsetTop = 48;\nvar defaultAnimTime = 1000;\nvar animTime;\n\n// do things!\n/**\n *  the function that goes in the loop\n */\nvar startTime, startPos, endPos;\nvar animFn = function () {\n  var now = new Date().getTime();\n  if (now - startTime < animTime)\n    window.scrollTo(0, eases.easeInOut(startPos, endPos - startPos, (now - startTime) / animTime));\n  else {\n    window.scrollTo(0, endPos);\n    loop.removeFunction(animFn);\n  }\n}\n\n/**\n *  Scroll to element or number\n *  @param {HTMLElement or string(id of element) or number}\n *  [@param {number}] position to start scrolling from\n *  [@param {boolean}] pass false to skip animation\n *  [@param {number}] time for animation\n *  [@param {number}] offset from top\n */\nvar scrollTo = function (dest, scrollPos, anim, time, offset) {\n  if (typeof dest === 'string') {\n    dest = document.getElementById(dest.replace('#',''));\n  }\n  if (typeof dest !== 'number') {\n    try {\n      dest = getPageOffset(dest).top - (isNaN(offset) ? defaultOffsetTop : offset);\n    } catch (err) {\n      return false;\n    }\n  }\n\n  loop.removeFunction(animFn);\n  if (anim !== false) {\n    startPos = scrollPos || getScrollPos();\n    endPos = dest;\n    startTime = new Date().getTime();\n    animTime = time || defaultAnimTime;\n\n    loop.addFunction(animFn);\n  }\n  else {\n    window.scrollTo(0, dest);\n  }\n\n  return true;\n}\n\nmodule.exports = scrollTo;\n\n},{\"lib/ease\":3,\"lib/getPageOffset\":4,\"lib/getScrollPos\":5,\"lib/loop\":7}],2:[function(require,module,exports){\nvar bps = [720,960,1200,1680];\n\nvar windowSize = require('lib/getWindowSize');\n\nvar getBreakpoint = function () {\n  var size = windowSize.width();\n  for (var i = 0; i < bps.length; i++) {\n    if (bps[i] > size)\n      return i;\n  }\n  return bps.length;\n}\n\nmodule.exports = getBreakpoint;\n\n},{\"lib/getWindowSize\":6}],3:[function(require,module,exports){\n// a bunch of easing functions for making animations\n// all accept start, change, and percent\n\nvar eases = {\n  'easeInOut' : function (s,c,p) {\n    if (p < .5) {\n      return s + c * (2 * p * p);\n    }\n    else {\n      return s + c * (-2 * (p - 1) * (p - 1) + 1);\n    }\n  },\n  'easeIn' : function (s,c,p) {\n    return s + c * p * p;\n  },\n  'easeInCubic' : function (s,c,p) {\n    return s + c * (p * p * p);\n  },\n  'easeOut' : function (s,c,p) {\n    return s + c * (-1 * (p - 1) * (p - 1) + 1);\n  },\n  'easeOutCubic' : function (s,c,p) {\n    return s + c * ((p - 1) * (p - 1) * (p - 1) + 1);\n  },\n  'linear' : function (s,c,p) {\n    return s + c * p;\n  }\n}\nmodule.exports = eases;\n\n},{}],4:[function(require,module,exports){\n/**\n *  Function: os.getPageOffset\n *  gets the page offset top and left of a DOM element\n */\nmodule.exports = function getPageOffset (element) {\n  if (!element) {\n    void 0;\n  }\n  var pageOffsetX = element.offsetLeft,\n  pageOffsetY = element.offsetTop;\n\n  while (element = element.offsetParent) {\n    pageOffsetX += element.offsetLeft;\n    pageOffsetY += element.offsetTop;\n  }\n\n  return {\n    left : pageOffsetX,\n    top : pageOffsetY\n  }\n}\n\n},{}],5:[function(require,module,exports){\n/**\n *  getScrollPos\n *\n *  cross browser way to get scrollTop\n */\nmodule.exports = (function (undefined) {\n  if (window.scrollY !== undefined)\n    return function getScrollPos () { return window.scrollY; }\n  else\n    return function getScrollPos () { return document.documentElement.scrollTop; }\n})();\n\n},{}],6:[function(require,module,exports){\n/**\n *  get window size, cross browser friendly\n *  call .width() or .height() to get the relevant value in pixels\n */\nvar windowHeight = function windowHeight () {\n  return window.innerHeight || document.documentElement.clientHeight;\n};\nvar windowWidth = function windowWidth () {\n  return window.innerWidth || document.documentElement.clientWidth;\n};\n\nmodule.exports = {\n  width: windowWidth,\n  height: windowHeight\n}\n\n},{}],7:[function(require,module,exports){\n/**\n *  Loop\n *\n *  The requestAnimationFrame Loop. It handles animation and state changes\n *  related to scrolling or window sizing. It can also be used for regular js\n *  driven animation as well.\n *\n *  To use:\n *    exports.addScrollFunction(fn) - adds a function to fire whenever scroll\n *      position changes\n *    exports.addResizeFunction(fn) - adds a function to fire whenever the\n *      window is resized, debounced by the value of the resizeDebounce var\n *    exports.addFunction(fn) - adds a function to fire on every iteration of\n *      the loop. Limit the use of this\n *    exports.removeFunction(fn) - removes a function from the list of functions\n *      to fire\n *    exports.start() - starts the loop (doesn't need to be called unless the\n *      loop was stopped at some point)\n *    exports.stop() - stops the loop\n *    exports.force() - forces the next iteration of the loop to fire scroll and\n *      resize functions, regardless of whether or not either things actually\n *      happened\n */\n\n/**\n * Provides requestAnimationFrame in a cross browser way.\n * @author paulirish / http://paulirish.com/\n */\nif ( !window.requestAnimationFrame ) {\n\twindow.requestAnimationFrame = ( function() {\n\t\treturn window.webkitRequestAnimationFrame ||\n\t\twindow.mozRequestAnimationFrame ||\n\t\twindow.oRequestAnimationFrame ||\n\t\twindow.msRequestAnimationFrame ||\n\t\tfunction( /* function FrameRequestCallback */ callback ) {\n\t\t\twindow.setTimeout( callback, 1000 / 60 );\n\t\t};\n\t} )();\n}\n\n;(function (document,window,undefined) {\n\n  // other lib helpers\n  var getScrollPos = require('lib/getScrollPos');\n\n  // private vars\n  var running = true,\n      lastBodyWidth = document.body.offsetWidth, // store width to determine if resize needed\n      lastBodyHeight = document.body.offsetHeight, // store height to determine if resize needed\n      lastScroll = -1,\n      lastTime = new Date().getTime(), // last time so we know how long it's been\n      resizeDebounce = 500\n      ;\n\n  // save the functions the loop should run\n  // will be passed currentTime, timeChange\n  var loopFuncs = {\n    resize : [], // functions to run on resize\n    scroll : [], // functions to run on scroll\n    tick : [] // functions to run every tick\n  };\n\n  // add/remove methods for those functions\n  var addLoopFunction = function addLoopFunction (type, fn) {\n    if (loopFuncs[type].indexOf(fn) === -1) { // make sure it doesn't already exist (only works with non-anonymous functions)\n      loopFuncs[type].push(fn);\n\t\t\tstart();\n      return true;\n    }\n    return false;\n  }\n  var addScrollFunction = function addScrollFunction (fn) {\n    return addLoopFunction('scroll',fn);\n  }\n  var addResizeFunction = function addResizeFunction (fn) {\n    return addLoopFunction('resize',fn);\n  }\n  var addFunction = function addFunction (fn) {\n    return addLoopFunction('tick',fn);\n  }\n  var removeFunction = function removeFunction (fn) {\n    var types = ['resize','scroll','tick'];\n    var found = false;\n    for (var i = 0; i < types.length; i++) {\n      var index = loopFuncs[types[i]].indexOf(fn);\n      if (index !== -1) {\n        loopFuncs[types[i]].splice(index,1);\n        found = true;\n        break;\n      }\n    }\n\t\t// check that we're still listening\n    for (var i = 0; i < types.length; i++) {\n\t\t\tif (loopFuncs[types[i]].length)\n\t\t\t\tbreak;\n\t\t\telse if (i === types.length - 1)\n\t\t\t\tstop();\n\t\t}\n    return found;\n  }\n\n  // do all functions of a given type\n  var doLoopFunctions = function doLoopFunctions (type,currentTime) {\n    for (var i = 0, len = loopFuncs[type].length; i < len; i++) {\n\t\t\tif (loopFuncs[type][i]) // extra check for safety\n      \tloopFuncs[type][i].call(window,currentTime);\n    }\n  }\n\n  // start/stop control\n  var start = function startLoop () {\n    running = true;\n\t\tloopFn();\n  }\n  var stop = function stopLoop () {\n    running = false;\n  }\n\n  // force it to fire next time through by setting lastScroll and lastBodyWidth\n  // to impossible values\n  var force = function forceLoop () {\n    lastBodyWidth = -1;\n    lastScroll = -1;\n  }\n\n  // hold a resize timout so we can debounce it\n  var resizeTimeout = null;\n\n  // the real deal!\n  // in a closure for maximum safety, and so it autostarts\n  // note: after checking using jsperf, rather than making one big todo array of\n  // all the functions, it's faster to call each array of functions separately\n  function loopFn() {\n\n    // check that we're actually running...\n    if (running) {\n\n      var currentTime = new Date().getTime();\n      var timeChange = currentTime - lastTime;\n      var currentScroll = getScrollPos();\n\n      // check if resize\n      if (document.body.offsetWidth !== lastBodyWidth || document.body.offsetHeight !== lastBodyHeight) {\n        // resize is true, save new sizes\n        lastBodyWidth = document.body.offsetWidth;\n        lastBodyHeight = document.body.offsetHeight;\n\n        if (resizeTimeout)\n          window.clearTimeout(resizeTimeout);\n        resizeTimeout = window.setTimeout(function () {\n          doLoopFunctions('resize',currentTime);\n        }, resizeDebounce);\n      }\n\n      // check if scroll\n      if (lastScroll !== currentScroll) {\n        // scroll is true, save new position\n        lastScroll = currentScroll;\n\n        // call each function\n        doLoopFunctions('scroll',currentTime);\n      }\n\n      // do the always functions\n      doLoopFunctions('tick',currentTime);\n\n      // save the new time\n      lastTime = currentTime;\n\n\t\t\t// make sure we do the tick again next time\n\t    requestAnimationFrame(loopFn);\n    }\n  };\n\n  // export the useful functions\n  module.exports = {\n    addScrollFunction: addScrollFunction,\n    addResizeFunction: addResizeFunction,\n    addFunction: addFunction,\n    removeFunction: removeFunction,\n    start: start,\n    stop: stop,\n    force: force\n  }\n\n})(document,window);\n\n},{\"lib/getScrollPos\":5}],8:[function(require,module,exports){\n/**\n *  Useful class for handling parallaxing things\n *  Stores object measurements and returns percentage of scroll when asked\n */\n\n// helpers\nvar getPageOffset = require('lib/getPageOffset'),\n    windowSize = require('lib/getWindowSize'),\n    getScrollPos = require('lib/getScrollPos'),\n    loop = require('lib/loop')\n    ;\n\n\nvar Parallax = function Parallax (element, onScroll) {\n  if (!this instanceof Parallax)\n    return new Parallax(element);\n\n  var _this = this;\n  this.element = element;\n\n  // get measurements immediately\n  this.measure();\n  if (onScroll)\n    onScroll(_this.getPercentage());\n\n  // listeners\n  this.onResize = function measureParallax () {\n    _this.measure();\n  }\n  if (onScroll) {\n    this.onScroll = function scrollParallax () {\n      onScroll.apply(_this, [_this.getPercentage()]);\n    }\n  }\n\n  // start 'er up\n  this.enable();\n}\nParallax.prototype = {\n  measure: function () {\n    var po = getPageOffset(this.element);\n    this.top = po.top - windowSize.height();\n    this.bottom = po.top + this.element.offsetHeight;\n    this.height = this.bottom - this.top;\n  },\n  getPercentage: function () {\n    var scrollY = getScrollPos();\n    var perc = (scrollY - this.top) / (this.height);\n    return perc;\n  },\n  disable: function () {\n    loop.removeFunction(this.onResize);\n    if (this.onScroll)\n      loop.removeFunction(this.onScroll);\n  },\n  enable: function () {\n    loop.addResizeFunction(this.onResize);\n    if (this.onScroll)\n      loop.addScrollFunction(this.onScroll);\n  },\n  destroy: function () {\n    this.disable();\n    delete this;\n  }\n}\n\nmodule.exports = Parallax;\n\n},{\"lib/getPageOffset\":4,\"lib/getScrollPos\":5,\"lib/getWindowSize\":6,\"lib/loop\":7}],9:[function(require,module,exports){\n/**\n *  Sets Transform styles cross browser\n *  @param {HTMLElement}\n *  @param {string} value of the transform style\n */\n\nvar transformAttributes = ['transform','webkitTransform','mozTransform','msTransform'];\nvar setTransform = function (element, transformString) {\n  for (var i = 0, len = transformAttributes.length; i < len; i++) {\n    element.style[transformAttributes[i]] = transformString;\n  }\n}\n\nmodule.exports = setTransform;\n\n},{}],10:[function(require,module,exports){\n/**\r\n *  Full Article controller\r\n */\r\n\r\n// requirements\r\nvar Halftone = require('objects/halftone');\r\nvar ScrollController = require('lib/scrollController');\r\nvar getScrollPos = require('lib/getScrollPos');\r\nvar getBreakpoint = require('lib/breakpoints');\r\nvar eases = require('lib/ease');\r\n\r\n// settings\r\nvar HEADER_HALFTONE_SETTINGS = {\r\n  fade: getBreakpoint() >= 2 ? 12 : 1,\r\n  inEaseStart: .1\r\n}\r\nvar INNER_HALFTONE_SETTINGS = {\r\n  fade: 0,\r\n  imageSizing: 'contain',\r\n  inEaseStart: .1, // scroll percentage to start animation in on first dot\r\n  inEaseEnd: .5, // scroll percentage to end animation in on last dot\r\n  outEaseStart: .75,\r\n  cornering: 8,\r\n  maxRadius: 12\r\n}\r\nvar RELATED_HALFTONE_SETTINGS = {\r\n  fade: 0,\r\n  inEaseStart: -.4,\r\n  inEaseEnd: .8,\r\n  inEaseFn: eases.linear,\r\n  outEaseStart: .6,\r\n  outEaseEnd: 1.2,\r\n  maxRadius: 12\r\n}\r\n\r\n/**\r\n *  Article class\r\n *  @param {HTMLElement} the whole damn article\r\n */\r\nvar Article = function (element) {\r\n  this.element = element;\r\n\r\n  // init header\r\n  var headerEl = element.querySelector('.article__header');\r\n  if (headerEl) {\r\n    this.header = new Halftone(headerEl, HEADER_HALFTONE_SETTINGS);\r\n    //this.header.animIn(1200);\r\n    window.header = this.header;\r\n  }\r\n\r\n  // init other halftones\r\n  var halftoneEls = element.querySelectorAll('.halftone');\r\n  this.halftones = [];\r\n  for (var i = 0, len = halftoneEls.length; i < len; i++) {\r\n    var ht = new Halftone(halftoneEls[i], INNER_HALFTONE_SETTINGS);\r\n    //ht.animIn(1200);\r\n    this.halftones.push(ht);\r\n  }\r\n\r\n  var relatedsEl = element.querySelector('.relateds');\r\n  if (relatedsEl) {\r\n    this.halftones.push(new Halftone(relatedsEl, RELATED_HALFTONE_SETTINGS));\r\n  }\r\n\r\n  // buttons\r\n  // var buttonEls = element.querySelectorAll('.button');\r\n  // this.buttons = [];\r\n  // for (var i = 0, len = buttonEls.length; i < len; i++) {\r\n  //   var ht = new Halftone(buttonEls[i], {\r\n  //     fade: 1,\r\n  //     inEaseStart: 0,\r\n  //     inEaseEnd: 1,\r\n  //     outEaseStart: 1.1,\r\n  //     outEaseEnd: 1.1,\r\n  //     control: 'none',\r\n  //     fill: '#046c6f'\r\n  //   });\r\n  //   buttonEls[i].addEventListener('mouseover',function () {\r\n  //     ht.anim(.5,1,3000);\r\n  //   }, false);\r\n  //   buttonEls[i].addEventListener('mouseout',function () {\r\n  //     ht.anim(1,.5,3000);\r\n  //   }, false);\r\n  //   this.halftones.push(ht);\r\n  // }\r\n\r\n  // listen for when to destroy\r\n  var _this = this;\r\n  var onScroll = function (scrollPercentage) {\r\n    if (getScrollPos() > this.bottom + 300)\r\n      _this.destroy(true);\r\n  }\r\n  this.scrollController = new ScrollController(this.element);\r\n}\r\nArticle.prototype = {\r\n  destroy: function (isPast) {\r\n    var newScrollPos = getScrollPos() - this.element.offsetHeight;\r\n    if (this.header)\r\n      this.header.destroy();\r\n    for (var i = 0, len = this.halftones.length; i < len; i++)\r\n      this.halftones[i].destroy();\r\n\r\n    this.scrollController.destroy();\r\n\r\n    // fix scroll position\r\n    if (isPast) {\r\n      var retried = false;\r\n      function fixScroll () {\r\n        window.scrollTo(0,newScrollPos);\r\n      }\r\n      fixScroll();\r\n      requestAnimationFrame(fixScroll);\r\n    }\r\n    this.element.remove();\r\n    //delete this;\r\n  }\r\n}\r\n\r\n// temp init article\r\nvar articleEl = document.querySelector('.article');\r\nif (articleEl)\r\n  new Article(document.querySelector('.article'));\r\n\n},{\"lib/breakpoints\":2,\"lib/ease\":3,\"lib/getScrollPos\":5,\"lib/scrollController\":8,\"objects/halftone\":12}],11:[function(require,module,exports){\n// requirements\r\nvar Halftone = require('objects/halftone');\r\nvar eases = require('lib/ease');\r\n\r\n// settings\r\n\r\n// init footer halftone\r\nvar footerHalftoneEl = document.querySelector('.footer-main__halftone');\r\nif (footerHalftoneEl) {\r\n  var footerHalftone = new Halftone (footerHalftoneEl, {\r\n    fade: 12,\r\n    maxRadius: 15,\r\n    inEaseStart: -.25,\r\n    inEaseEnd: .1,\r\n    inEaseFn: eases.linear,\r\n    outEaseStart: 1,\r\n    outEaseEnd: 1\r\n  });\r\n}\r\n\n},{\"lib/ease\":3,\"objects/halftone\":12}],12:[function(require,module,exports){\n/**\r\n *  Controls cool halftone thingies\r\n */\r\n\r\n// requirements\r\nvar eases = require('lib/ease');\r\nvar ScrollController = require('lib/scrollController');\r\nvar setTransform = require('lib/setTransform');\r\nvar windowSize = require('lib/getWindowSize');\r\nvar getBreakpoint = require('lib/breakpoints');\r\nvar loop = require('lib/loop');\r\n\r\n// settings\r\nvar DEFAULTS = {\r\n  fade: 4, // rows to fade top and bottom, if 0 the canvas is sized to be contained instead of overflow on the sides\r\n  maxRadius: 15, // maximum radius for a dot\r\n  inEaseFn: eases.easeOut,\r\n  inEaseStart: .2, // scroll percentage to start animation in on first dot\r\n  inEaseEnd: .8, // scroll percentage to end animation in on last dot\r\n  outEaseFn: eases.linear,\r\n  outEaseStart: .6, // scroll percentage to start animation out on first dot\r\n  outEaseEnd: 1.1, // scroll percentage to end animation out on last dot\r\n  fixed: false, // fixed position and full screen?\r\n  imageSizing: 'cover', // 'cover' or 'contain'\r\n  cornering: 0, // diagnal top left fade\r\n  control: 'scroll', // 'scroll', 'mouse' (TODO), or 'none'\r\n  fill: null, // optionally override fill color\r\n  initialDrawPercentage: .55, // percentage to draw right away\r\n  minBreakpoint: 0 // minimum breakpoint that canvas can exist\r\n}\r\nvar BREAKPOINT_FOR_SCROLL_CONTROL = 2;\r\n\r\n/**\r\n *  Dot class\r\n *  @param {int} grid position X\r\n *  @param {int} grid position Y\r\n *  @param {Number} max radius\r\n *  @param {Halftone} parent halftone object\r\n *\r\n *  @method draw ({canvas context})\r\n *  @method setRadiusByPercentage ({percent of max radius})\r\n */\r\nvar Dot = function (gridX, gridY, maxRadius, parent) {\r\n  this.gridX = gridX;\r\n  this.gridY = gridY;\r\n  this.maxRadius = maxRadius;\r\n  this.radius = maxRadius;\r\n  this.parent = parent;\r\n  this.percentage = (this.gridX + this.gridY) / (this.parent.columns + this.parent.rows);\r\n\r\n  // define location within canvas context\r\n  this.x = this.gridX * this.parent.settings.maxRadius;\r\n  this.y = this.gridY * this.parent.settings.maxRadius;\r\n  if (this.parent.settings.fade)\r\n    this.y += this.parent.settings.maxRadius;\r\n\r\n  // handle cornering\r\n  if (this.parent.settings.cornering && this.gridX + this.gridY <= this.parent.settings.cornering + 1) {\r\n    this.maxRadius = eases.linear(.33,.66,(this.gridX + this.gridY) / (this.parent.settings.cornering + 1)) * this.maxRadius;\r\n    this.radius = this.maxRadius;\r\n  }\r\n  else if (this.parent.settings.cornering && -1 * ((this.gridX + this.gridY) - (this.parent.columns + this.parent.rows - 2)) <= this.parent.settings.cornering + 1) {\r\n    this.maxRadius = eases.linear(.33,.66,-1 * ((this.gridX + this.gridY) - (this.parent.columns + this.parent.rows - 2)) / (this.parent.settings.cornering + 1)) * this.maxRadius;\r\n    this.radius = this.maxRadius;\r\n  }\r\n}\r\nDot.prototype = {\r\n  draw: function (ctx) {\r\n    if (this.radius > .5) {\r\n      ctx.moveTo(this.x, this.y - this.radius);\r\n      ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);\r\n    }\r\n  },\r\n  setRadiusByPercentage: function (percent) {\r\n    this.radius = Math.max(0, Math.min(this.maxRadius, percent * this.maxRadius));\r\n  }\r\n}\r\n\r\n/**\r\n *  Halftone class\r\n *  @param {HTMLElement} element, optionally with a background image, to turn into the toy\r\n *  @param {object} settings that can override DEFAULTS defined above\r\n *\r\n *  @method draw({percentage of animation progress})\r\n *  @method createCanvas()\r\n *  @method sizeImage() - for internal use\r\n *  @method getPercentageFromScroll() - returns a percentage of progress past element based on scrolling\r\n *  @method init()\r\n *  @method destroy()\r\n *  @method animIn({animation time in ms})\r\n */\r\nvar Halftone = function (element, settings, dotSizeImage) {\r\n  var _this = this;\r\n  this.element = element;\r\n  this.settings = {};\r\n  settings = settings || {};\r\n  for (var prop in DEFAULTS) {\r\n    this.settings[prop] = settings[prop] !== undefined ? settings[prop] : DEFAULTS[prop];\r\n  }\r\n\r\n  if (dotSizeImage) {\r\n    this.dotSizeImage = new Image();\r\n    this.dotSizeImage.src = dotSizeImage;\r\n    this.dotSizeImage.onload = function () {\r\n      _this.sizeDotsByImage();\r\n      _this.lastDrawnPercentage = null;\r\n      _this.draw(_this.getPercentageFromScroll());\r\n    }\r\n  }\r\n\r\n\r\n  var computedStyle = getComputedStyle(this.element);\r\n  // make sure positioning is valid\r\n  if (computedStyle.position === 'static') {\r\n    this.element.style.position = 'relative';\r\n  }\r\n  // set up color and image\r\n  this.fill = this.settings.fill || computedStyle.backgroundColor;\r\n  if (!!computedStyle.backgroundImage && computedStyle.backgroundImage !== 'none') {\r\n    this.image = new Image();\r\n    this.image.src = computedStyle.backgroundImage.match(/\\((?:'|\")?(.+?)(?:'|\")?\\)/)[1];\r\n  }\r\n  if (!this.settings.fill)\r\n    this.element.style.background = 'none';\r\n\r\n  // listeners\r\n  this.onResize = function () {\r\n    _this.createCanvas();\r\n  }\r\n  this.onScroll = function (percentage) {\r\n    _this.draw(percentage);\r\n  }\r\n\r\n  // autostart\r\n  this.init();\r\n}\r\nHalftone.prototype = {\r\n  draw: function (percentage) {\r\n    // round to .1%\r\n    percentage = Math.round(percentage * 1000) / 1000;\r\n\r\n    // should we bother?\r\n    if (!this.canvas || percentage == this.lastDrawnPercentage || (percentage < this.settings.inEaseStart || percentage > this.settings.outEaseEnd)) {\r\n      return false;\r\n    }\r\n\r\n      void 0;\r\n\r\n    // clear current crap\r\n    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n\r\n    // have to do the maths\r\n    this.ctx.save();\r\n    this.ctx.beginPath();\r\n    // handle animation\r\n    // in vars\r\n    var effectiveInPerc = (percentage - this.settings.inEaseStart) / (this.settings.inEaseEnd - this.settings.inEaseStart);\r\n    effectiveInPerc = effectiveInPerc < 1 ? this.settings.inEaseFn(-1,3,effectiveInPerc) : 2;\r\n    // out vars\r\n    var effectiveOutPerc = (percentage - this.settings.outEaseStart) / (this.settings.outEaseEnd - this.settings.outEaseStart);\r\n    effectiveOutPerc = effectiveOutPerc > 0 ? this.settings.outEaseFn(2,-3,effectiveOutPerc) : 2;\r\n\r\n    for (var i = 0, len = this.dots.length; i < len; i++) {\r\n      var dotInPerc = effectiveInPerc - this.dots[i].percentage;\r\n      var dotOutPerc = effectiveOutPerc - (1 - this.dots[i].percentage);\r\n      this.dots[i].setRadiusByPercentage(Math.min(dotInPerc,dotOutPerc));\r\n      this.dots[i].draw(this.ctx);\r\n    }\r\n\r\n    this.ctx.fill();\r\n\r\n    if (this.image && this.imageOffsets) {\r\n      this.ctx.globalCompositeOperation = \"source-atop\";\r\n      this.ctx.drawImage(this.image, this.imageOffsets.x, this.imageOffsets.y, this.imageOffsets.width, this.imageOffsets.height);\r\n    }\r\n    this.ctx.restore();\r\n\r\n    this.lastDrawnPercentage = percentage;\r\n  },\r\n  createCanvas: function () {\r\n    if (getBreakpoint() < this.settings.minBreakpoint) {\r\n      void 0;\r\n      // we want no canvas!\r\n      if (this.canvas) {\r\n        this.canvas.remove();\r\n        this.canvas = null;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    // good to actually make the thing\r\n    var _this = this;\r\n    function addCanvas () {\r\n      if (_this.element.children.length) {\r\n        _this.element.insertBefore(_this.canvas, _this.element.children[0]);\r\n      }\r\n      else {\r\n        _this.element.appendChild(_this.canvas);\r\n      }\r\n    }\r\n    function enableCanvas () {\r\n      // establish scroll based controls only if screen is large enough for us to care\r\n      if (getBreakpoint() >= BREAKPOINT_FOR_SCROLL_CONTROL && _this.settings.control === 'scroll') {\r\n        _this.scrollController = new ScrollController(_this.element, _this.onScroll);\r\n      }\r\n      else {\r\n        if (_this.scrollController) {\r\n          _this.scrollController.destroy();\r\n          _this.scrollController = null;\r\n        }\r\n        _this.draw(_this.getPercentageFromScroll());\r\n      }\r\n    }\r\n\r\n    // kill existing canvas\r\n    this.lastDrawnPercentage = null;\r\n    var lastCanvas;\r\n    if (this.canvas) {\r\n      lastCanvas = this.canvas;\r\n    }\r\n\r\n    // create new canvas and dots\r\n    this.canvas = document.createElement('canvas');\r\n    this.canvas.setAttribute('class','canvas-halftone');\r\n    if (!this.settings.fixed || getBreakpoint() < BREAKPOINT_FOR_SCROLL_CONTROL) {\r\n      // normal sizing and positioning\r\n      var columns = Math.floor(this.element.offsetWidth / this.settings.maxRadius);\r\n      var rows = Math.floor(this.element.offsetHeight / this.settings.maxRadius);\r\n      if (this.settings.fade) {\r\n        columns += 2;\r\n        rows += this.settings.fade * 2 + 2;\r\n      }\r\n      else {\r\n        if (columns % 2 === 0)\r\n          columns += 1;\r\n        if (rows % 2 === 0)\r\n          rows += 1;\r\n      }\r\n    }\r\n    else {\r\n      // fixed sizing and positioning\r\n      var columns = Math.floor(windowSize.width() / this.settings.maxRadius) + 2;\r\n      var rows = Math.floor(windowSize.height() / this.settings.maxRadius) + this.settings.fade * 2 + 2;\r\n      setTransform(this.element,'none');\r\n      setTransform(this.canvas,'none');\r\n      this.canvas.style.position = 'fixed';\r\n      this.canvas.style.top = this.settings.fade * this.settings.maxRadius * -1 - (this.settings.maxRadius) + 'px';\r\n      this.canvas.style.left = 0;\r\n    }\r\n    this.canvas.width = (columns - 1) * this.settings.maxRadius;\r\n    this.canvas.height = (this.settings.fade ? rows + 1 : rows - 1) * this.settings.maxRadius;\r\n\r\n    // check that we even need to do this shit\r\n    if (lastCanvas && lastCanvas.width === this.canvas.width && lastCanvas.height === this.canvas.height) {\r\n      // stop remaking, it's the same!\r\n      this.canvas = lastCanvas;\r\n      //addCanvas();\r\n      enableCanvas();\r\n      return;\r\n    }\r\n    else if (lastCanvas) {\r\n      lastCanvas.remove();\r\n    }\r\n\r\n    // set the context\r\n    this.ctx = this.canvas.getContext('2d');\r\n    this.ctx.fillStyle = this.fill;\r\n    this.columns = columns;\r\n    this.rows = rows;\r\n\r\n    // define the dots\r\n    this.dots = [];\r\n    for (var y = 0; y < rows; y++) {\r\n      for (var x = 0; x < columns; x+= 2) {\r\n        var rad;\r\n        if (y < this.settings.fade) {\r\n          rad = (y + 1) / (this.settings.fade + 1) * this.settings.maxRadius;\r\n        }\r\n        else if (y >= rows - this.settings.fade) {\r\n          rad = -1 * (y + 1 - rows) / (this.settings.fade + 1) * this.settings.maxRadius;\r\n        }\r\n        else if (!this.settings.fade && y === 0 && x === 0 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else if (!this.settings.fade && y === 0 && x === columns - 1 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else if (!this.settings.fade && y === rows - 1 && x === 0 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else if (!this.settings.fade && y === rows - 1 && x === columns - 1 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else {\r\n          rad = this.settings.maxRadius;\r\n        }\r\n        this.dots.push(new Dot(y % 2 ? x + 1 : x, y, rad, this));\r\n      }\r\n    }\r\n\r\n    if (this.element.children.length) {\r\n      this.element.insertBefore(this.canvas, this.element.children[0]);\r\n    }\r\n    else {\r\n      this.element.appendChild(this.canvas);\r\n    }\r\n\r\n    // determine image size\r\n    if (this.image) {\r\n      if (this.image.complete) {\r\n        this.imageOffsets = this.sizeImage(this.image);\r\n      }\r\n      else {\r\n        var _this = this;\r\n        this.image.onload = function () {\r\n          _this.imageOffsets = _this.sizeImage(_this.image);\r\n          _this.lastDrawnPercentage = null;\r\n          _this.draw(_this.getPercentageFromScroll());\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.dotSizeImage && this.dotSizeImage.complete) {\r\n      this.sizeDotsByImage();\r\n    }\r\n\r\n    enableCanvas();\r\n  },\r\n  sizeImage: function (image) {\r\n    // make sure we successfully loaded\r\n    if (!image || !image.width || !image.height) {\r\n      return false;\r\n    }\r\n\r\n    // figure out the scale to match 'cover' or 'contain', as defined by settings\r\n    var scale = this.canvas.width / image.width;\r\n    if (this.settings.imageSizing === 'cover' && scale * image.height < this.canvas.height) {\r\n      scale = this.canvas.height / image.height;\r\n    }\r\n    else if (this.settings.imageSizing === 'contain' && scale * image.height > this.canvas.height) {\r\n      scale = this.canvas.height / image.height;\r\n    }\r\n    // save the x,y,width,height of the scaled image so it can be easily drawn without math\r\n    return {\r\n      x: (this.canvas.width - image.width * scale) / 2,\r\n      y: (this.canvas.height - image.height * scale) / 2,\r\n      width: image.width * scale,\r\n      height: image.height * scale\r\n    }\r\n  },\r\n  sizeDotsByImage: function () {\r\n    // first, figure out how to size the image for the canvas\r\n    var dotsImageOffsets = this.sizeImage(this.dotSizeImage);\r\n    if (!dotsImageOffsets) {\r\n      return;\r\n    }\r\n\r\n    var tempCan = document.createElement('canvas');\r\n    tempCan.width = this.canvas.width;\r\n    tempCan.height = this.canvas.height;\r\n    var tempCanCtx = tempCan.getContext('2d');\r\n    tempCanCtx.fillStyle = 'white';\r\n    tempCanCtx.fillRect(0, 0, tempCan.width, tempCan.height);\r\n    tempCanCtx.drawImage(this.dotSizeImage, dotsImageOffsets.x, dotsImageOffsets.y, dotsImageOffsets.width, dotsImageOffsets.height);\r\n\r\n    for (var i = this.dots.length - 1; i >= 0; i--) {\r\n      var imgData = tempCanCtx.getImageData(this.dots[i].x - this.settings.maxRadius, this.dots[i].y - this.settings.maxRadius, this.settings.maxRadius * 2, this.settings.maxRadius * 2);\r\n      //console.log(this.dots[i].x - this.settings.maxRadius, this.dots[i].y - this.settings.maxRadius, this.settings.maxRadius * 2, this.settings.maxRadius * 2);\r\n      // only getting red, because image should be greyscale anyway\r\n      var averageRed = 0;\r\n      for (var j = 0, jLen = imgData.data.length; j < jLen; j += 4) {\r\n        var opacityAdd = (255 - imgData.data[j]) * ((255 - imgData.data[j + 3]) / 255);\r\n        averageRed += imgData.data[j] + opacityAdd;\r\n        // if (j < 400)\r\n        //   console.log(imgData.data[j], opacityAdd, imgData.data[j] + opacityAdd);\r\n      }\r\n      averageRed /= (imgData.data.length / 4);\r\n\r\n      this.dots[i].maxRadius = this.dots[i].maxRadius * ((255 - averageRed) / 255);\r\n      // remove this dot if it will never show\r\n      if (this.dots[i].maxRadius < .5) {\r\n        this.dots.splice(i,1);\r\n      }\r\n    }\r\n  },\r\n  getPercentageFromScroll: function () {\r\n    return (this.scrollController && getBreakpoint() >= BREAKPOINT_FOR_SCROLL_CONTROL) ? this.scrollController.getPercentage() : this.settings.initialDrawPercentage;\r\n  },\r\n  init: function () {\r\n    // make the canvas\r\n    this.createCanvas();\r\n\r\n    // scroll listener added in createCanvas fn\r\n\r\n    // listen for resize\r\n    loop.addResizeFunction(this.onResize);\r\n  },\r\n  destroy: function () {\r\n    if (this.scrollController)\r\n      this.scrollController.destroy();\r\n    loop.removeFunction(this.onResize);\r\n    this.canvas.remove();\r\n    delete this;\r\n  },\r\n  anim: function (startPerc, endPerc, time, ease, cb) {\r\n    // first, turn off scroll listening\r\n    if (this.scrollController)\r\n      this.scrollController.disable();\r\n    // establish defaults\r\n    startPerc = startPerc || 0;\r\n    endPerc = !isNaN(endPerc) ? endPerc : 1;\r\n    time = time || 1000;\r\n    ease = ease || eases.easeInOut;\r\n    // get some base vars\r\n    var startTime = new Date().getTime();\r\n    var deltaPerc = endPerc - startPerc;\r\n    var _this = this;\r\n    var running = true;\r\n    // this goes in the loop\r\n    var animationFn = function () {\r\n      if (running) {\r\n        var now = new Date().getTime();\r\n        var deltaTime = (now - startTime) / time;\r\n        if (deltaTime < 1)\r\n          _this.draw(ease(startPerc,deltaPerc,deltaTime));\r\n        else {\r\n          running = false;\r\n          _this.draw(endPerc);\r\n          if (_this.scrollController)\r\n            _this.scrollController.enable();\r\n          // get back out of the loop\r\n          loop.removeFunction(animationFn);\r\n          if (cb)\r\n            cb();\r\n        }\r\n      }\r\n    }\r\n    loop.addFunction(animationFn);\r\n  },\r\n  animIn: function (time, cb) {\r\n    // animate the canvas from inEaseStart to current scroll pos\r\n    // check if we even need to\r\n    var endPerc = this.getPercentageFromScroll();\r\n    if (endPerc < this.settings.inEaseStart)\r\n      return false;\r\n\r\n    this.anim(this.settings.inEaseStart, endPerc, time, eases.easeOut, cb);\r\n  },\r\n  animOut: function (time, cb) {\r\n    // animate the canvas from inEaseStart to current scroll pos\r\n    // check if we even need to\r\n    var startPerc = this.getPercentageFromScroll();\r\n    if (startPerc < this.settings.inEaseStart)\r\n      return false;\r\n\r\n    this.anim(startPerc, this.settings.inEaseStart, time, eases.easeIn, cb);\r\n  }\r\n}\r\n\r\n// temp auto init\r\n// var htrEls = document.querySelectorAll('.halftone');\r\n// var htrs = [];\r\n// for (var i = 0, len = htrEls.length; i < len; i++) {\r\n//   htrs.push(new Halftone(htrEls[i], { fade: 12, fixed: false }));\r\n// }\r\n// window.htrs = htrs;\r\nmodule.exports = Halftone;\r\n\n},{\"lib/breakpoints\":2,\"lib/ease\":3,\"lib/getWindowSize\":6,\"lib/loop\":7,\"lib/scrollController\":8,\"lib/setTransform\":9}],13:[function(require,module,exports){\n/**\r\n *  controls illustrations\r\n */\r\n// requirements\r\nvar Halftone = require('objects/halftone');\r\nvar eases = require('lib/ease');\r\n\r\n// settings\r\nvar ILLUSTRATION_HALFTONE_SETTINGS = {\r\n  fade: 0,\r\n  fixed: true,\r\n  inEaseStart: 0,\r\n  inEaseEnd: .45,\r\n  inEaseFn: eases.linear,\r\n  outEaseStart: .55,\r\n  outEaseEnd: 1,\r\n  imageSizing: 'contain',\r\n  minBreakpoint: 2\r\n};\r\n\r\n/**\r\n *  Illustration object\r\n *  @param {HTMLElement}\r\n */\r\nvar Illustration = function (element) {\r\n  this.element = element;\r\n  this.image = element.querySelector('.illustration__image');\r\n  this.halftone = new Halftone(this.image, ILLUSTRATION_HALFTONE_SETTINGS);\r\n}\r\n\r\n// init\r\nvar illustrationEls = document.querySelectorAll('.illustration');\r\nfor (var i = 0, len = illustrationEls.length; i < len; i++) {\r\n  new Illustration(illustrationEls[i]);\r\n}\r\n\n},{\"lib/ease\":3,\"objects/halftone\":12}],14:[function(require,module,exports){\n/**\r\n *  The My Titles toy\r\n */\r\n// requirements\r\nvar Halftone = require('objects/halftone');\r\nvar eases = require('lib/ease');\r\nvar windowSize = require('lib/getWindowSize');\r\n\r\n// settings\r\nvar HALFTONE_SETTINGS = {\r\n  inEaseFn: eases.easeOut,\r\n  inEaseStart: -.1,\r\n  inEaseEnd: .5,\r\n  outEaseFn: eases.easeIn,\r\n  outEaseStart: .5,\r\n  outEaseEnd: 1.1,\r\n  fade: 1,\r\n  fill: '#011C1F',\r\n  maxRadius: 9,\r\n  control: 'none',\r\n  initialDrawPercentage: 0\r\n}\r\nvar ANIM_TIME = 10000;\r\n\r\n/**\r\n *  MyTitles\r\n *  @param {HTMLElement}\r\n */\r\nvar MyTitles = function (element) {\r\n  this.element = element;\r\n\r\n  this.halftones = [];\r\n  this.halftones.push(new Halftone(element, HALFTONE_SETTINGS, '/images/dotsize-musician.jpg'));\r\n  this.halftones.push(new Halftone(element, HALFTONE_SETTINGS, '/images/dotsize-goalie.jpg'));\r\n  this.halftones.push(new Halftone(element, HALFTONE_SETTINGS, '/images/dotsize-geek.jpg'));\r\n  // for (var i = 0, len = this.halftones.length; i < len; i++) {\r\n  //   this.halftones[i].draw(0);\r\n  // }\r\n  var index = -1;\r\n  var _this = this;\r\n  function animNext () {\r\n    index = (index + 1) % _this.halftones.length;\r\n    //console.log(index);\r\n    _this.halftones[index].anim(0,1,ANIM_TIME,eases.linear);\r\n  }\r\n  //this.halftones[0].anim(.5,1,ANIM_TIME / 2,eases.linear);\r\n  animNext();\r\n  window.setInterval(animNext,ANIM_TIME * .8);\r\n}\r\n\r\nvar myTitlesEls = document.querySelectorAll('.my-titles');\r\nfor (var i = 0, len = myTitlesEls.length; i < len; i++) {\r\n  new MyTitles(myTitlesEls[i]);\r\n}\r\n\n},{\"lib/ease\":3,\"lib/getWindowSize\":6,\"objects/halftone\":12}],15:[function(require,module,exports){\n/**\r\n *  Scrolls the screen to the top of .header-main on load if pageType is defined\r\n */\r\n// requirements\r\nvar getScrollPos = require('lib/getScrollPos');\r\nvar animateScrollTo = require('lib/animateScrollTo');\r\n\r\n// do it right away\r\nvar headerMain = document.querySelector('.header-main');\r\nvar pageType = document.body.getAttribute('data-page-type');\r\n\r\nif (pageType && pageType !== 'index' && headerMain) {\r\n  window.setTimeout(function () {\r\n    if (getScrollPos() < 50)\r\n      animateScrollTo(headerMain, null, null, 600, 0);\r\n  }, window.sessionStorage.getItem('seenNav') ? 100 : 600);\r\n  window.sessionStorage.setItem('seenNav',true);\r\n}\r\n\n},{\"lib/animateScrollTo\":1,\"lib/getScrollPos\":5}],16:[function(require,module,exports){\n/**\n *  scripts.js\n *  This should include objects, which in turn include the lib files they need.\n *  This keeps us using a modular approach to dev while also only including the\n *  parts of the library we need.\n */\n// objects\nrequire('objects/scrollOnLoad');\nrequire('objects/article');\nrequire('objects/illustration');\nrequire('objects/footer');\nrequire('objects/myTitles');\n\n},{\"objects/article\":10,\"objects/footer\":11,\"objects/illustration\":13,\"objects/myTitles\":14,\"objects/scrollOnLoad\":15}]},{},[16])\n\n","var bps = [720,960,1200,1680];\n\nvar windowSize = require('lib/getWindowSize');\n\nvar getBreakpoint = function () {\n  var size = windowSize.width();\n  for (var i = 0; i < bps.length; i++) {\n    if (bps[i] > size)\n      return i;\n  }\n  return bps.length;\n}\n\nmodule.exports = getBreakpoint;\n","// a bunch of easing functions for making animations\n// all accept start, change, and percent\n\nvar eases = {\n  'easeInOut' : function (s,c,p) {\n    if (p < .5) {\n      return s + c * (2 * p * p);\n    }\n    else {\n      return s + c * (-2 * (p - 1) * (p - 1) + 1);\n    }\n  },\n  'easeIn' : function (s,c,p) {\n    return s + c * p * p;\n  },\n  'easeInCubic' : function (s,c,p) {\n    return s + c * (p * p * p);\n  },\n  'easeOut' : function (s,c,p) {\n    return s + c * (-1 * (p - 1) * (p - 1) + 1);\n  },\n  'easeOutCubic' : function (s,c,p) {\n    return s + c * ((p - 1) * (p - 1) * (p - 1) + 1);\n  },\n  'linear' : function (s,c,p) {\n    return s + c * p;\n  }\n}\nmodule.exports = eases;\n","/**\n *  Function: os.getPageOffset\n *  gets the page offset top and left of a DOM element\n */\nmodule.exports = function getPageOffset (element) {\n  if (!element) {\n    console.error('getPageOffset passed an invalid element:', element);\n  }\n  var pageOffsetX = element.offsetLeft,\n  pageOffsetY = element.offsetTop;\n\n  while (element = element.offsetParent) {\n    pageOffsetX += element.offsetLeft;\n    pageOffsetY += element.offsetTop;\n  }\n\n  return {\n    left : pageOffsetX,\n    top : pageOffsetY\n  }\n}\n","/**\n *  getScrollPos\n *\n *  cross browser way to get scrollTop\n */\nmodule.exports = (function (undefined) {\n  if (window.scrollY !== undefined)\n    return function getScrollPos () { return window.scrollY; }\n  else\n    return function getScrollPos () { return document.documentElement.scrollTop; }\n})();\n","/**\n *  get window size, cross browser friendly\n *  call .width() or .height() to get the relevant value in pixels\n */\nvar windowHeight = function windowHeight () {\n  return window.innerHeight || document.documentElement.clientHeight;\n};\nvar windowWidth = function windowWidth () {\n  return window.innerWidth || document.documentElement.clientWidth;\n};\n\nmodule.exports = {\n  width: windowWidth,\n  height: windowHeight\n}\n","/**\n *  Loop\n *\n *  The requestAnimationFrame Loop. It handles animation and state changes\n *  related to scrolling or window sizing. It can also be used for regular js\n *  driven animation as well.\n *\n *  To use:\n *    exports.addScrollFunction(fn) - adds a function to fire whenever scroll\n *      position changes\n *    exports.addResizeFunction(fn) - adds a function to fire whenever the\n *      window is resized, debounced by the value of the resizeDebounce var\n *    exports.addFunction(fn) - adds a function to fire on every iteration of\n *      the loop. Limit the use of this\n *    exports.removeFunction(fn) - removes a function from the list of functions\n *      to fire\n *    exports.start() - starts the loop (doesn't need to be called unless the\n *      loop was stopped at some point)\n *    exports.stop() - stops the loop\n *    exports.force() - forces the next iteration of the loop to fire scroll and\n *      resize functions, regardless of whether or not either things actually\n *      happened\n */\n\n/**\n * Provides requestAnimationFrame in a cross browser way.\n * @author paulirish / http://paulirish.com/\n */\nif ( !window.requestAnimationFrame ) {\n\twindow.requestAnimationFrame = ( function() {\n\t\treturn window.webkitRequestAnimationFrame ||\n\t\twindow.mozRequestAnimationFrame ||\n\t\twindow.oRequestAnimationFrame ||\n\t\twindow.msRequestAnimationFrame ||\n\t\tfunction( /* function FrameRequestCallback */ callback ) {\n\t\t\twindow.setTimeout( callback, 1000 / 60 );\n\t\t};\n\t} )();\n}\n\n;(function (document,window,undefined) {\n\n  // other lib helpers\n  var getScrollPos = require('lib/getScrollPos');\n\n  // private vars\n  var running = true,\n      lastBodyWidth = document.body.offsetWidth, // store width to determine if resize needed\n      lastBodyHeight = document.body.offsetHeight, // store height to determine if resize needed\n      lastScroll = -1,\n      lastTime = new Date().getTime(), // last time so we know how long it's been\n      resizeDebounce = 500\n      ;\n\n  // save the functions the loop should run\n  // will be passed currentTime, timeChange\n  var loopFuncs = {\n    resize : [], // functions to run on resize\n    scroll : [], // functions to run on scroll\n    tick : [] // functions to run every tick\n  };\n\n  // add/remove methods for those functions\n  var addLoopFunction = function addLoopFunction (type, fn) {\n    if (loopFuncs[type].indexOf(fn) === -1) { // make sure it doesn't already exist (only works with non-anonymous functions)\n      loopFuncs[type].push(fn);\n\t\t\tstart();\n      return true;\n    }\n    return false;\n  }\n  var addScrollFunction = function addScrollFunction (fn) {\n    return addLoopFunction('scroll',fn);\n  }\n  var addResizeFunction = function addResizeFunction (fn) {\n    return addLoopFunction('resize',fn);\n  }\n  var addFunction = function addFunction (fn) {\n    return addLoopFunction('tick',fn);\n  }\n  var removeFunction = function removeFunction (fn) {\n    var types = ['resize','scroll','tick'];\n    var found = false;\n    for (var i = 0; i < types.length; i++) {\n      var index = loopFuncs[types[i]].indexOf(fn);\n      if (index !== -1) {\n        loopFuncs[types[i]].splice(index,1);\n        found = true;\n        break;\n      }\n    }\n\t\t// check that we're still listening\n    for (var i = 0; i < types.length; i++) {\n\t\t\tif (loopFuncs[types[i]].length)\n\t\t\t\tbreak;\n\t\t\telse if (i === types.length - 1)\n\t\t\t\tstop();\n\t\t}\n    return found;\n  }\n\n  // do all functions of a given type\n  var doLoopFunctions = function doLoopFunctions (type,currentTime) {\n    for (var i = 0, len = loopFuncs[type].length; i < len; i++) {\n\t\t\tif (loopFuncs[type][i]) // extra check for safety\n      \tloopFuncs[type][i].call(window,currentTime);\n    }\n  }\n\n  // start/stop control\n  var start = function startLoop () {\n    running = true;\n\t\tloopFn();\n  }\n  var stop = function stopLoop () {\n    running = false;\n  }\n\n  // force it to fire next time through by setting lastScroll and lastBodyWidth\n  // to impossible values\n  var force = function forceLoop () {\n    lastBodyWidth = -1;\n    lastScroll = -1;\n  }\n\n  // hold a resize timout so we can debounce it\n  var resizeTimeout = null;\n\n  // the real deal!\n  // in a closure for maximum safety, and so it autostarts\n  // note: after checking using jsperf, rather than making one big todo array of\n  // all the functions, it's faster to call each array of functions separately\n  function loopFn() {\n\n    // check that we're actually running...\n    if (running) {\n\n      var currentTime = new Date().getTime();\n      var timeChange = currentTime - lastTime;\n      var currentScroll = getScrollPos();\n\n      // check if resize\n      if (document.body.offsetWidth !== lastBodyWidth || document.body.offsetHeight !== lastBodyHeight) {\n        // resize is true, save new sizes\n        lastBodyWidth = document.body.offsetWidth;\n        lastBodyHeight = document.body.offsetHeight;\n\n        if (resizeTimeout)\n          window.clearTimeout(resizeTimeout);\n        resizeTimeout = window.setTimeout(function () {\n          doLoopFunctions('resize',currentTime);\n        }, resizeDebounce);\n      }\n\n      // check if scroll\n      if (lastScroll !== currentScroll) {\n        // scroll is true, save new position\n        lastScroll = currentScroll;\n\n        // call each function\n        doLoopFunctions('scroll',currentTime);\n      }\n\n      // do the always functions\n      doLoopFunctions('tick',currentTime);\n\n      // save the new time\n      lastTime = currentTime;\n\n\t\t\t// make sure we do the tick again next time\n\t    requestAnimationFrame(loopFn);\n    }\n  };\n\n  // export the useful functions\n  module.exports = {\n    addScrollFunction: addScrollFunction,\n    addResizeFunction: addResizeFunction,\n    addFunction: addFunction,\n    removeFunction: removeFunction,\n    start: start,\n    stop: stop,\n    force: force\n  }\n\n})(document,window);\n","/**\n *  Useful class for handling parallaxing things\n *  Stores object measurements and returns percentage of scroll when asked\n */\n\n// helpers\nvar getPageOffset = require('lib/getPageOffset'),\n    windowSize = require('lib/getWindowSize'),\n    getScrollPos = require('lib/getScrollPos'),\n    loop = require('lib/loop')\n    ;\n\n\nvar Parallax = function Parallax (element, onScroll) {\n  if (!this instanceof Parallax)\n    return new Parallax(element);\n\n  var _this = this;\n  this.element = element;\n\n  // get measurements immediately\n  this.measure();\n  if (onScroll)\n    onScroll(_this.getPercentage());\n\n  // listeners\n  this.onResize = function measureParallax () {\n    _this.measure();\n  }\n  if (onScroll) {\n    this.onScroll = function scrollParallax () {\n      onScroll.apply(_this, [_this.getPercentage()]);\n    }\n  }\n\n  // start 'er up\n  this.enable();\n}\nParallax.prototype = {\n  measure: function () {\n    var po = getPageOffset(this.element);\n    this.top = po.top - windowSize.height();\n    this.bottom = po.top + this.element.offsetHeight;\n    this.height = this.bottom - this.top;\n  },\n  getPercentage: function () {\n    var scrollY = getScrollPos();\n    var perc = (scrollY - this.top) / (this.height);\n    return perc;\n  },\n  disable: function () {\n    loop.removeFunction(this.onResize);\n    if (this.onScroll)\n      loop.removeFunction(this.onScroll);\n  },\n  enable: function () {\n    loop.addResizeFunction(this.onResize);\n    if (this.onScroll)\n      loop.addScrollFunction(this.onScroll);\n  },\n  destroy: function () {\n    this.disable();\n    delete this;\n  }\n}\n\nmodule.exports = Parallax;\n","/**\n *  Sets Transform styles cross browser\n *  @param {HTMLElement}\n *  @param {string} value of the transform style\n */\n\nvar transformAttributes = ['transform','webkitTransform','mozTransform','msTransform'];\nvar setTransform = function (element, transformString) {\n  for (var i = 0, len = transformAttributes.length; i < len; i++) {\n    element.style[transformAttributes[i]] = transformString;\n  }\n}\n\nmodule.exports = setTransform;\n","/**\r\n *  Full Article controller\r\n */\r\n\r\n// requirements\r\nvar Halftone = require('objects/halftone');\r\nvar ScrollController = require('lib/scrollController');\r\nvar getScrollPos = require('lib/getScrollPos');\r\nvar getBreakpoint = require('lib/breakpoints');\r\nvar eases = require('lib/ease');\r\n\r\n// settings\r\nvar HEADER_HALFTONE_SETTINGS = {\r\n  fade: getBreakpoint() >= 2 ? 12 : 1,\r\n  inEaseStart: .1\r\n}\r\nvar INNER_HALFTONE_SETTINGS = {\r\n  fade: 0,\r\n  imageSizing: 'contain',\r\n  inEaseStart: .1, // scroll percentage to start animation in on first dot\r\n  inEaseEnd: .5, // scroll percentage to end animation in on last dot\r\n  outEaseStart: .75,\r\n  cornering: 8,\r\n  maxRadius: 12\r\n}\r\nvar RELATED_HALFTONE_SETTINGS = {\r\n  fade: 0,\r\n  inEaseStart: -.4,\r\n  inEaseEnd: .8,\r\n  inEaseFn: eases.linear,\r\n  outEaseStart: .6,\r\n  outEaseEnd: 1.2,\r\n  maxRadius: 12\r\n}\r\n\r\n/**\r\n *  Article class\r\n *  @param {HTMLElement} the whole damn article\r\n */\r\nvar Article = function (element) {\r\n  this.element = element;\r\n\r\n  // init header\r\n  var headerEl = element.querySelector('.article__header');\r\n  if (headerEl) {\r\n    this.header = new Halftone(headerEl, HEADER_HALFTONE_SETTINGS);\r\n    //this.header.animIn(1200);\r\n    window.header = this.header;\r\n  }\r\n\r\n  // init other halftones\r\n  var halftoneEls = element.querySelectorAll('.halftone');\r\n  this.halftones = [];\r\n  for (var i = 0, len = halftoneEls.length; i < len; i++) {\r\n    var ht = new Halftone(halftoneEls[i], INNER_HALFTONE_SETTINGS);\r\n    //ht.animIn(1200);\r\n    this.halftones.push(ht);\r\n  }\r\n\r\n  var relatedsEl = element.querySelector('.relateds');\r\n  if (relatedsEl) {\r\n    this.halftones.push(new Halftone(relatedsEl, RELATED_HALFTONE_SETTINGS));\r\n  }\r\n\r\n  // buttons\r\n  // var buttonEls = element.querySelectorAll('.button');\r\n  // this.buttons = [];\r\n  // for (var i = 0, len = buttonEls.length; i < len; i++) {\r\n  //   var ht = new Halftone(buttonEls[i], {\r\n  //     fade: 1,\r\n  //     inEaseStart: 0,\r\n  //     inEaseEnd: 1,\r\n  //     outEaseStart: 1.1,\r\n  //     outEaseEnd: 1.1,\r\n  //     control: 'none',\r\n  //     fill: '#046c6f'\r\n  //   });\r\n  //   buttonEls[i].addEventListener('mouseover',function () {\r\n  //     ht.anim(.5,1,3000);\r\n  //   }, false);\r\n  //   buttonEls[i].addEventListener('mouseout',function () {\r\n  //     ht.anim(1,.5,3000);\r\n  //   }, false);\r\n  //   this.halftones.push(ht);\r\n  // }\r\n\r\n  // listen for when to destroy\r\n  var _this = this;\r\n  var onScroll = function (scrollPercentage) {\r\n    if (getScrollPos() > this.bottom + 300)\r\n      _this.destroy(true);\r\n  }\r\n  this.scrollController = new ScrollController(this.element);\r\n}\r\nArticle.prototype = {\r\n  destroy: function (isPast) {\r\n    var newScrollPos = getScrollPos() - this.element.offsetHeight;\r\n    if (this.header)\r\n      this.header.destroy();\r\n    for (var i = 0, len = this.halftones.length; i < len; i++)\r\n      this.halftones[i].destroy();\r\n\r\n    this.scrollController.destroy();\r\n\r\n    // fix scroll position\r\n    if (isPast) {\r\n      var retried = false;\r\n      function fixScroll () {\r\n        window.scrollTo(0,newScrollPos);\r\n      }\r\n      fixScroll();\r\n      requestAnimationFrame(fixScroll);\r\n    }\r\n    this.element.remove();\r\n    //delete this;\r\n  }\r\n}\r\n\r\n// temp init article\r\nvar articleEl = document.querySelector('.article');\r\nif (articleEl)\r\n  new Article(document.querySelector('.article'));\r\n","// requirements\r\nvar Halftone = require('objects/halftone');\r\nvar eases = require('lib/ease');\r\n\r\n// settings\r\n\r\n// init footer halftone\r\nvar footerHalftoneEl = document.querySelector('.footer-main__halftone');\r\nif (footerHalftoneEl) {\r\n  var footerHalftone = new Halftone (footerHalftoneEl, {\r\n    fade: 12,\r\n    maxRadius: 15,\r\n    inEaseStart: -.25,\r\n    inEaseEnd: .1,\r\n    inEaseFn: eases.linear,\r\n    outEaseStart: 1,\r\n    outEaseEnd: 1\r\n  });\r\n}\r\n","/**\r\n *  Controls cool halftone thingies\r\n */\r\n\r\n// requirements\r\nvar eases = require('lib/ease');\r\nvar ScrollController = require('lib/scrollController');\r\nvar setTransform = require('lib/setTransform');\r\nvar windowSize = require('lib/getWindowSize');\r\nvar getBreakpoint = require('lib/breakpoints');\r\nvar loop = require('lib/loop');\r\n\r\n// settings\r\nvar DEFAULTS = {\r\n  fade: 4, // rows to fade top and bottom, if 0 the canvas is sized to be contained instead of overflow on the sides\r\n  maxRadius: 15, // maximum radius for a dot\r\n  inEaseFn: eases.easeOut,\r\n  inEaseStart: .2, // scroll percentage to start animation in on first dot\r\n  inEaseEnd: .8, // scroll percentage to end animation in on last dot\r\n  outEaseFn: eases.linear,\r\n  outEaseStart: .6, // scroll percentage to start animation out on first dot\r\n  outEaseEnd: 1.1, // scroll percentage to end animation out on last dot\r\n  fixed: false, // fixed position and full screen?\r\n  imageSizing: 'cover', // 'cover' or 'contain'\r\n  cornering: 0, // diagnal top left fade\r\n  control: 'scroll', // 'scroll', 'mouse' (TODO), or 'none'\r\n  fill: null, // optionally override fill color\r\n  initialDrawPercentage: .55, // percentage to draw right away\r\n  minBreakpoint: 0 // minimum breakpoint that canvas can exist\r\n}\r\nvar BREAKPOINT_FOR_SCROLL_CONTROL = 2;\r\n\r\n/**\r\n *  Dot class\r\n *  @param {int} grid position X\r\n *  @param {int} grid position Y\r\n *  @param {Number} max radius\r\n *  @param {Halftone} parent halftone object\r\n *\r\n *  @method draw ({canvas context})\r\n *  @method setRadiusByPercentage ({percent of max radius})\r\n */\r\nvar Dot = function (gridX, gridY, maxRadius, parent) {\r\n  this.gridX = gridX;\r\n  this.gridY = gridY;\r\n  this.maxRadius = maxRadius;\r\n  this.radius = maxRadius;\r\n  this.parent = parent;\r\n  this.percentage = (this.gridX + this.gridY) / (this.parent.columns + this.parent.rows);\r\n\r\n  // define location within canvas context\r\n  this.x = this.gridX * this.parent.settings.maxRadius;\r\n  this.y = this.gridY * this.parent.settings.maxRadius;\r\n  if (this.parent.settings.fade)\r\n    this.y += this.parent.settings.maxRadius;\r\n\r\n  // handle cornering\r\n  if (this.parent.settings.cornering && this.gridX + this.gridY <= this.parent.settings.cornering + 1) {\r\n    this.maxRadius = eases.linear(.33,.66,(this.gridX + this.gridY) / (this.parent.settings.cornering + 1)) * this.maxRadius;\r\n    this.radius = this.maxRadius;\r\n  }\r\n  else if (this.parent.settings.cornering && -1 * ((this.gridX + this.gridY) - (this.parent.columns + this.parent.rows - 2)) <= this.parent.settings.cornering + 1) {\r\n    this.maxRadius = eases.linear(.33,.66,-1 * ((this.gridX + this.gridY) - (this.parent.columns + this.parent.rows - 2)) / (this.parent.settings.cornering + 1)) * this.maxRadius;\r\n    this.radius = this.maxRadius;\r\n  }\r\n}\r\nDot.prototype = {\r\n  draw: function (ctx) {\r\n    if (this.radius > .5) {\r\n      ctx.moveTo(this.x, this.y - this.radius);\r\n      ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);\r\n    }\r\n  },\r\n  setRadiusByPercentage: function (percent) {\r\n    this.radius = Math.max(0, Math.min(this.maxRadius, percent * this.maxRadius));\r\n  }\r\n}\r\n\r\n/**\r\n *  Halftone class\r\n *  @param {HTMLElement} element, optionally with a background image, to turn into the toy\r\n *  @param {object} settings that can override DEFAULTS defined above\r\n *\r\n *  @method draw({percentage of animation progress})\r\n *  @method createCanvas()\r\n *  @method sizeImage() - for internal use\r\n *  @method getPercentageFromScroll() - returns a percentage of progress past element based on scrolling\r\n *  @method init()\r\n *  @method destroy()\r\n *  @method animIn({animation time in ms})\r\n */\r\nvar Halftone = function (element, settings, dotSizeImage) {\r\n  var _this = this;\r\n  this.element = element;\r\n  this.settings = {};\r\n  settings = settings || {};\r\n  for (var prop in DEFAULTS) {\r\n    this.settings[prop] = settings[prop] !== undefined ? settings[prop] : DEFAULTS[prop];\r\n  }\r\n\r\n  if (dotSizeImage) {\r\n    this.dotSizeImage = new Image();\r\n    this.dotSizeImage.src = dotSizeImage;\r\n    this.dotSizeImage.onload = function () {\r\n      _this.sizeDotsByImage();\r\n      _this.lastDrawnPercentage = null;\r\n      _this.draw(_this.getPercentageFromScroll());\r\n    }\r\n  }\r\n\r\n\r\n  var computedStyle = getComputedStyle(this.element);\r\n  // make sure positioning is valid\r\n  if (computedStyle.position === 'static') {\r\n    this.element.style.position = 'relative';\r\n  }\r\n  // set up color and image\r\n  this.fill = this.settings.fill || computedStyle.backgroundColor;\r\n  if (!!computedStyle.backgroundImage && computedStyle.backgroundImage !== 'none') {\r\n    this.image = new Image();\r\n    this.image.src = computedStyle.backgroundImage.match(/\\((?:'|\")?(.+?)(?:'|\")?\\)/)[1];\r\n  }\r\n  if (!this.settings.fill)\r\n    this.element.style.background = 'none';\r\n\r\n  // listeners\r\n  this.onResize = function () {\r\n    _this.createCanvas();\r\n  }\r\n  this.onScroll = function (percentage) {\r\n    _this.draw(percentage);\r\n  }\r\n\r\n  // autostart\r\n  this.init();\r\n}\r\nHalftone.prototype = {\r\n  draw: function (percentage) {\r\n    // round to .1%\r\n    percentage = Math.round(percentage * 1000) / 1000;\r\n\r\n    // should we bother?\r\n    if (!this.canvas || percentage == this.lastDrawnPercentage || (percentage < this.settings.inEaseStart || percentage > this.settings.outEaseEnd)) {\r\n      return false;\r\n    }\r\n\r\n      console.log('draw');\r\n\r\n    // clear current crap\r\n    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n\r\n    // have to do the maths\r\n    this.ctx.save();\r\n    this.ctx.beginPath();\r\n    // handle animation\r\n    // in vars\r\n    var effectiveInPerc = (percentage - this.settings.inEaseStart) / (this.settings.inEaseEnd - this.settings.inEaseStart);\r\n    effectiveInPerc = effectiveInPerc < 1 ? this.settings.inEaseFn(-1,3,effectiveInPerc) : 2;\r\n    // out vars\r\n    var effectiveOutPerc = (percentage - this.settings.outEaseStart) / (this.settings.outEaseEnd - this.settings.outEaseStart);\r\n    effectiveOutPerc = effectiveOutPerc > 0 ? this.settings.outEaseFn(2,-3,effectiveOutPerc) : 2;\r\n\r\n    for (var i = 0, len = this.dots.length; i < len; i++) {\r\n      var dotInPerc = effectiveInPerc - this.dots[i].percentage;\r\n      var dotOutPerc = effectiveOutPerc - (1 - this.dots[i].percentage);\r\n      this.dots[i].setRadiusByPercentage(Math.min(dotInPerc,dotOutPerc));\r\n      this.dots[i].draw(this.ctx);\r\n    }\r\n\r\n    this.ctx.fill();\r\n\r\n    if (this.image && this.imageOffsets) {\r\n      this.ctx.globalCompositeOperation = \"source-atop\";\r\n      this.ctx.drawImage(this.image, this.imageOffsets.x, this.imageOffsets.y, this.imageOffsets.width, this.imageOffsets.height);\r\n    }\r\n    this.ctx.restore();\r\n\r\n    this.lastDrawnPercentage = percentage;\r\n  },\r\n  createCanvas: function () {\r\n    if (getBreakpoint() < this.settings.minBreakpoint) {\r\n      console.log('too small!', this.canvas);\r\n      // we want no canvas!\r\n      if (this.canvas) {\r\n        this.canvas.remove();\r\n        this.canvas = null;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    // good to actually make the thing\r\n    var _this = this;\r\n    function addCanvas () {\r\n      if (_this.element.children.length) {\r\n        _this.element.insertBefore(_this.canvas, _this.element.children[0]);\r\n      }\r\n      else {\r\n        _this.element.appendChild(_this.canvas);\r\n      }\r\n    }\r\n    function enableCanvas () {\r\n      // establish scroll based controls only if screen is large enough for us to care\r\n      if (getBreakpoint() >= BREAKPOINT_FOR_SCROLL_CONTROL && _this.settings.control === 'scroll') {\r\n        _this.scrollController = new ScrollController(_this.element, _this.onScroll);\r\n      }\r\n      else {\r\n        if (_this.scrollController) {\r\n          _this.scrollController.destroy();\r\n          _this.scrollController = null;\r\n        }\r\n        _this.draw(_this.getPercentageFromScroll());\r\n      }\r\n    }\r\n\r\n    // kill existing canvas\r\n    this.lastDrawnPercentage = null;\r\n    var lastCanvas;\r\n    if (this.canvas) {\r\n      lastCanvas = this.canvas;\r\n    }\r\n\r\n    // create new canvas and dots\r\n    this.canvas = document.createElement('canvas');\r\n    this.canvas.setAttribute('class','canvas-halftone');\r\n    if (!this.settings.fixed || getBreakpoint() < BREAKPOINT_FOR_SCROLL_CONTROL) {\r\n      // normal sizing and positioning\r\n      var columns = Math.floor(this.element.offsetWidth / this.settings.maxRadius);\r\n      var rows = Math.floor(this.element.offsetHeight / this.settings.maxRadius);\r\n      if (this.settings.fade) {\r\n        columns += 2;\r\n        rows += this.settings.fade * 2 + 2;\r\n      }\r\n      else {\r\n        if (columns % 2 === 0)\r\n          columns += 1;\r\n        if (rows % 2 === 0)\r\n          rows += 1;\r\n      }\r\n    }\r\n    else {\r\n      // fixed sizing and positioning\r\n      var columns = Math.floor(windowSize.width() / this.settings.maxRadius) + 2;\r\n      var rows = Math.floor(windowSize.height() / this.settings.maxRadius) + this.settings.fade * 2 + 2;\r\n      setTransform(this.element,'none');\r\n      setTransform(this.canvas,'none');\r\n      this.canvas.style.position = 'fixed';\r\n      this.canvas.style.top = this.settings.fade * this.settings.maxRadius * -1 - (this.settings.maxRadius) + 'px';\r\n      this.canvas.style.left = 0;\r\n    }\r\n    this.canvas.width = (columns - 1) * this.settings.maxRadius;\r\n    this.canvas.height = (this.settings.fade ? rows + 1 : rows - 1) * this.settings.maxRadius;\r\n\r\n    // check that we even need to do this shit\r\n    if (lastCanvas && lastCanvas.width === this.canvas.width && lastCanvas.height === this.canvas.height) {\r\n      // stop remaking, it's the same!\r\n      this.canvas = lastCanvas;\r\n      //addCanvas();\r\n      enableCanvas();\r\n      return;\r\n    }\r\n    else if (lastCanvas) {\r\n      lastCanvas.remove();\r\n    }\r\n\r\n    // set the context\r\n    this.ctx = this.canvas.getContext('2d');\r\n    this.ctx.fillStyle = this.fill;\r\n    this.columns = columns;\r\n    this.rows = rows;\r\n\r\n    // define the dots\r\n    this.dots = [];\r\n    for (var y = 0; y < rows; y++) {\r\n      for (var x = 0; x < columns; x+= 2) {\r\n        var rad;\r\n        if (y < this.settings.fade) {\r\n          rad = (y + 1) / (this.settings.fade + 1) * this.settings.maxRadius;\r\n        }\r\n        else if (y >= rows - this.settings.fade) {\r\n          rad = -1 * (y + 1 - rows) / (this.settings.fade + 1) * this.settings.maxRadius;\r\n        }\r\n        else if (!this.settings.fade && y === 0 && x === 0 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else if (!this.settings.fade && y === 0 && x === columns - 1 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else if (!this.settings.fade && y === rows - 1 && x === 0 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else if (!this.settings.fade && y === rows - 1 && x === columns - 1 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else {\r\n          rad = this.settings.maxRadius;\r\n        }\r\n        this.dots.push(new Dot(y % 2 ? x + 1 : x, y, rad, this));\r\n      }\r\n    }\r\n\r\n    if (this.element.children.length) {\r\n      this.element.insertBefore(this.canvas, this.element.children[0]);\r\n    }\r\n    else {\r\n      this.element.appendChild(this.canvas);\r\n    }\r\n\r\n    // determine image size\r\n    if (this.image) {\r\n      if (this.image.complete) {\r\n        this.imageOffsets = this.sizeImage(this.image);\r\n      }\r\n      else {\r\n        var _this = this;\r\n        this.image.onload = function () {\r\n          _this.imageOffsets = _this.sizeImage(_this.image);\r\n          _this.lastDrawnPercentage = null;\r\n          _this.draw(_this.getPercentageFromScroll());\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.dotSizeImage && this.dotSizeImage.complete) {\r\n      this.sizeDotsByImage();\r\n    }\r\n\r\n    enableCanvas();\r\n  },\r\n  sizeImage: function (image) {\r\n    // make sure we successfully loaded\r\n    if (!image || !image.width || !image.height) {\r\n      return false;\r\n    }\r\n\r\n    // figure out the scale to match 'cover' or 'contain', as defined by settings\r\n    var scale = this.canvas.width / image.width;\r\n    if (this.settings.imageSizing === 'cover' && scale * image.height < this.canvas.height) {\r\n      scale = this.canvas.height / image.height;\r\n    }\r\n    else if (this.settings.imageSizing === 'contain' && scale * image.height > this.canvas.height) {\r\n      scale = this.canvas.height / image.height;\r\n    }\r\n    // save the x,y,width,height of the scaled image so it can be easily drawn without math\r\n    return {\r\n      x: (this.canvas.width - image.width * scale) / 2,\r\n      y: (this.canvas.height - image.height * scale) / 2,\r\n      width: image.width * scale,\r\n      height: image.height * scale\r\n    }\r\n  },\r\n  sizeDotsByImage: function () {\r\n    // first, figure out how to size the image for the canvas\r\n    var dotsImageOffsets = this.sizeImage(this.dotSizeImage);\r\n    if (!dotsImageOffsets) {\r\n      return;\r\n    }\r\n\r\n    var tempCan = document.createElement('canvas');\r\n    tempCan.width = this.canvas.width;\r\n    tempCan.height = this.canvas.height;\r\n    var tempCanCtx = tempCan.getContext('2d');\r\n    tempCanCtx.fillStyle = 'white';\r\n    tempCanCtx.fillRect(0, 0, tempCan.width, tempCan.height);\r\n    tempCanCtx.drawImage(this.dotSizeImage, dotsImageOffsets.x, dotsImageOffsets.y, dotsImageOffsets.width, dotsImageOffsets.height);\r\n\r\n    for (var i = this.dots.length - 1; i >= 0; i--) {\r\n      var imgData = tempCanCtx.getImageData(this.dots[i].x - this.settings.maxRadius, this.dots[i].y - this.settings.maxRadius, this.settings.maxRadius * 2, this.settings.maxRadius * 2);\r\n      //console.log(this.dots[i].x - this.settings.maxRadius, this.dots[i].y - this.settings.maxRadius, this.settings.maxRadius * 2, this.settings.maxRadius * 2);\r\n      // only getting red, because image should be greyscale anyway\r\n      var averageRed = 0;\r\n      for (var j = 0, jLen = imgData.data.length; j < jLen; j += 4) {\r\n        var opacityAdd = (255 - imgData.data[j]) * ((255 - imgData.data[j + 3]) / 255);\r\n        averageRed += imgData.data[j] + opacityAdd;\r\n        // if (j < 400)\r\n        //   console.log(imgData.data[j], opacityAdd, imgData.data[j] + opacityAdd);\r\n      }\r\n      averageRed /= (imgData.data.length / 4);\r\n\r\n      this.dots[i].maxRadius = this.dots[i].maxRadius * ((255 - averageRed) / 255);\r\n      // remove this dot if it will never show\r\n      if (this.dots[i].maxRadius < .5) {\r\n        this.dots.splice(i,1);\r\n      }\r\n    }\r\n  },\r\n  getPercentageFromScroll: function () {\r\n    return (this.scrollController && getBreakpoint() >= BREAKPOINT_FOR_SCROLL_CONTROL) ? this.scrollController.getPercentage() : this.settings.initialDrawPercentage;\r\n  },\r\n  init: function () {\r\n    // make the canvas\r\n    this.createCanvas();\r\n\r\n    // scroll listener added in createCanvas fn\r\n\r\n    // listen for resize\r\n    loop.addResizeFunction(this.onResize);\r\n  },\r\n  destroy: function () {\r\n    if (this.scrollController)\r\n      this.scrollController.destroy();\r\n    loop.removeFunction(this.onResize);\r\n    this.canvas.remove();\r\n    delete this;\r\n  },\r\n  anim: function (startPerc, endPerc, time, ease, cb) {\r\n    // first, turn off scroll listening\r\n    if (this.scrollController)\r\n      this.scrollController.disable();\r\n    // establish defaults\r\n    startPerc = startPerc || 0;\r\n    endPerc = !isNaN(endPerc) ? endPerc : 1;\r\n    time = time || 1000;\r\n    ease = ease || eases.easeInOut;\r\n    // get some base vars\r\n    var startTime = new Date().getTime();\r\n    var deltaPerc = endPerc - startPerc;\r\n    var _this = this;\r\n    var running = true;\r\n    // this goes in the loop\r\n    var animationFn = function () {\r\n      if (running) {\r\n        var now = new Date().getTime();\r\n        var deltaTime = (now - startTime) / time;\r\n        if (deltaTime < 1)\r\n          _this.draw(ease(startPerc,deltaPerc,deltaTime));\r\n        else {\r\n          running = false;\r\n          _this.draw(endPerc);\r\n          if (_this.scrollController)\r\n            _this.scrollController.enable();\r\n          // get back out of the loop\r\n          loop.removeFunction(animationFn);\r\n          if (cb)\r\n            cb();\r\n        }\r\n      }\r\n    }\r\n    loop.addFunction(animationFn);\r\n  },\r\n  animIn: function (time, cb) {\r\n    // animate the canvas from inEaseStart to current scroll pos\r\n    // check if we even need to\r\n    var endPerc = this.getPercentageFromScroll();\r\n    if (endPerc < this.settings.inEaseStart)\r\n      return false;\r\n\r\n    this.anim(this.settings.inEaseStart, endPerc, time, eases.easeOut, cb);\r\n  },\r\n  animOut: function (time, cb) {\r\n    // animate the canvas from inEaseStart to current scroll pos\r\n    // check if we even need to\r\n    var startPerc = this.getPercentageFromScroll();\r\n    if (startPerc < this.settings.inEaseStart)\r\n      return false;\r\n\r\n    this.anim(startPerc, this.settings.inEaseStart, time, eases.easeIn, cb);\r\n  }\r\n}\r\n\r\n// temp auto init\r\n// var htrEls = document.querySelectorAll('.halftone');\r\n// var htrs = [];\r\n// for (var i = 0, len = htrEls.length; i < len; i++) {\r\n//   htrs.push(new Halftone(htrEls[i], { fade: 12, fixed: false }));\r\n// }\r\n// window.htrs = htrs;\r\nmodule.exports = Halftone;\r\n","/**\r\n *  controls illustrations\r\n */\r\n// requirements\r\nvar Halftone = require('objects/halftone');\r\nvar eases = require('lib/ease');\r\n\r\n// settings\r\nvar ILLUSTRATION_HALFTONE_SETTINGS = {\r\n  fade: 0,\r\n  fixed: true,\r\n  inEaseStart: 0,\r\n  inEaseEnd: .45,\r\n  inEaseFn: eases.linear,\r\n  outEaseStart: .55,\r\n  outEaseEnd: 1,\r\n  imageSizing: 'contain',\r\n  minBreakpoint: 2\r\n};\r\n\r\n/**\r\n *  Illustration object\r\n *  @param {HTMLElement}\r\n */\r\nvar Illustration = function (element) {\r\n  this.element = element;\r\n  this.image = element.querySelector('.illustration__image');\r\n  this.halftone = new Halftone(this.image, ILLUSTRATION_HALFTONE_SETTINGS);\r\n}\r\n\r\n// init\r\nvar illustrationEls = document.querySelectorAll('.illustration');\r\nfor (var i = 0, len = illustrationEls.length; i < len; i++) {\r\n  new Illustration(illustrationEls[i]);\r\n}\r\n","/**\r\n *  The My Titles toy\r\n */\r\n// requirements\r\nvar Halftone = require('objects/halftone');\r\nvar eases = require('lib/ease');\r\nvar windowSize = require('lib/getWindowSize');\r\n\r\n// settings\r\nvar HALFTONE_SETTINGS = {\r\n  inEaseFn: eases.easeOut,\r\n  inEaseStart: -.1,\r\n  inEaseEnd: .5,\r\n  outEaseFn: eases.easeIn,\r\n  outEaseStart: .5,\r\n  outEaseEnd: 1.1,\r\n  fade: 1,\r\n  fill: '#011C1F',\r\n  maxRadius: 9,\r\n  control: 'none',\r\n  initialDrawPercentage: 0\r\n}\r\nvar ANIM_TIME = 10000;\r\n\r\n/**\r\n *  MyTitles\r\n *  @param {HTMLElement}\r\n */\r\nvar MyTitles = function (element) {\r\n  this.element = element;\r\n\r\n  this.halftones = [];\r\n  this.halftones.push(new Halftone(element, HALFTONE_SETTINGS, '/images/dotsize-musician.jpg'));\r\n  this.halftones.push(new Halftone(element, HALFTONE_SETTINGS, '/images/dotsize-goalie.jpg'));\r\n  this.halftones.push(new Halftone(element, HALFTONE_SETTINGS, '/images/dotsize-geek.jpg'));\r\n  // for (var i = 0, len = this.halftones.length; i < len; i++) {\r\n  //   this.halftones[i].draw(0);\r\n  // }\r\n  var index = -1;\r\n  var _this = this;\r\n  function animNext () {\r\n    index = (index + 1) % _this.halftones.length;\r\n    //console.log(index);\r\n    _this.halftones[index].anim(0,1,ANIM_TIME,eases.linear);\r\n  }\r\n  //this.halftones[0].anim(.5,1,ANIM_TIME / 2,eases.linear);\r\n  animNext();\r\n  window.setInterval(animNext,ANIM_TIME * .8);\r\n}\r\n\r\nvar myTitlesEls = document.querySelectorAll('.my-titles');\r\nfor (var i = 0, len = myTitlesEls.length; i < len; i++) {\r\n  new MyTitles(myTitlesEls[i]);\r\n}\r\n","/**\r\n *  Scrolls the screen to the top of .header-main on load if pageType is defined\r\n */\r\n// requirements\r\nvar getScrollPos = require('lib/getScrollPos');\r\nvar animateScrollTo = require('lib/animateScrollTo');\r\n\r\n// do it right away\r\nvar headerMain = document.querySelector('.header-main');\r\nvar pageType = document.body.getAttribute('data-page-type');\r\n\r\nif (pageType && pageType !== 'index' && headerMain) {\r\n  window.setTimeout(function () {\r\n    if (getScrollPos() < 50)\r\n      animateScrollTo(headerMain, null, null, 600, 0);\r\n  }, window.sessionStorage.getItem('seenNav') ? 100 : 600);\r\n  window.sessionStorage.setItem('seenNav',true);\r\n}\r\n","/**\n *  scripts.js\n *  This should include objects, which in turn include the lib files they need.\n *  This keeps us using a modular approach to dev while also only including the\n *  parts of the library we need.\n */\n// objects\nrequire('objects/scrollOnLoad');\nrequire('objects/article');\nrequire('objects/illustration');\nrequire('objects/footer');\nrequire('objects/myTitles');\n"],"sourceRoot":"/source/"}