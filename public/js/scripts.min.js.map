{"version":3,"sources":["../../node_modules/browser-pack/_prelude.js","lib/breakpoints.js","scripts.min.js","lib/ease.js","lib/getPageOffset.js","lib/getScrollPos.js","lib/getWindowSize.js","lib/loop.js","lib/scrollController.js","lib/setTransform.js","objects/article.js","objects/halftone.js","scripts.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","bps","windowSize","getBreakpoint","size","width","lib/getWindowSize",2,"eases","easeInOut","c","p","easeIn","easeInCubic","easeOut","easeOutCubic","linear",3,"element","pageOffsetX","offsetLeft","pageOffsetY","offsetTop","offsetParent","left","top",4,"undefined","window","scrollY","document","documentElement","scrollTop",5,"windowHeight","innerHeight","clientHeight","windowWidth","innerWidth","clientWidth","height",6,"requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","callback","setTimeout","loopFn","running","currentTime","Date","getTime","currentScroll","getScrollPos","body","offsetWidth","lastBodyWidth","offsetHeight","lastBodyHeight","resizeTimeout","clearTimeout","doLoopFunctions","resizeDebounce","lastScroll","lastTime","loopFuncs","resize","scroll","tick","addLoopFunction","type","fn","indexOf","push","start","addScrollFunction","addResizeFunction","addFunction","removeFunction","types","found","index","splice","stop","len","force","lib/getScrollPos",7,"getPageOffset","loop","Parallax","onScroll","this","_this","measure","getPercentage","onResize","enable","prototype","po","bottom","perc","disable","destroy","lib/getPageOffset","lib/loop",8,"transformAttributes","setTransform","transformString","style",9,"Halftone","HEADER_HALFTONE_SETTINGS","fade","INNER_HALFTONE_SETTINGS","imageSizing","inEaseStart","inEaseEnd","cornering","Article","headerEl","querySelector","header","animIn","halftoneEls","querySelectorAll","halftones","ht","article","objects/halftone",10,"ScrollController","DEFAULTS","maxRadius","inEaseFn","outEaseFn","outEaseStart","outEaseEnd","fixed","control","Dot","gridX","gridY","parent","radius","percentage","columns","rows","x","settings","y","draw","ctx","moveTo","arc","Math","PI","setRadiusByPercentage","percent","max","min","prop","computedStyle","getComputedStyle","position","fill","backgroundColor","backgroundImage","image","Image","src","match","background","createCanvas","init","canvas","clearRect","save","beginPath","effectiveInPerc","effectiveOutPerc","dots","dotInPerc","dotOutPerc","imageOffsets","globalCompositeOperation","drawImage","restore","remove","createElement","setAttribute","floor","getContext","fillStyle","rad","appendChild","complete","sizeImage","onload","getPercentageFromScroll","scrollController","scale","anim","startPerc","endPerc","time","ease","cb","startTime","deltaPerc","animationFn","now","deltaTime","animOut","lib/breakpoints","lib/ease","lib/scrollController","lib/setTransform",11,"objects/article"],"mappings":"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","file":"scripts.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var bps = [720,960,1200,1680];\n\nvar windowSize = require('lib/getWindowSize');\n\nvar getBreakpoint = function () {\n  var size = windowSize.width();\n  for (var i = 0; i < bps.length; i++) {\n    if (bps[i] > size)\n      return i;\n  }\n  return bps.length;\n}\n\nmodule.exports = getBreakpoint;\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar bps = [720,960,1200,1680];\n\nvar windowSize = require('lib/getWindowSize');\n\nvar getBreakpoint = function () {\n  var size = windowSize.width();\n  for (var i = 0; i < bps.length; i++) {\n    if (bps[i] > size)\n      return i;\n  }\n  return bps.length;\n}\n\nmodule.exports = getBreakpoint;\n\n},{\"lib/getWindowSize\":5}],2:[function(require,module,exports){\n// a bunch of easing functions for making animations\n// all accept start, change, and percent\n\nvar eases = {\n  'easeInOut' : function (s,c,p) {\n    if (p < .5) {\n      return s + c * (2 * p * p);\n    }\n    else {\n      return s + c * (-2 * (p - 1) * (p - 1) + 1);\n    }\n  },\n  'easeIn' : function (s,c,p) {\n    return s + c * p * p;\n  },\n  'easeInCubic' : function (s,c,p) {\n    return s + c * (p * p * p);\n  },\n  'easeOut' : function (s,c,p) {\n    return s + c * (-1 * (p - 1) * (p - 1) + 1);\n  },\n  'easeOutCubic' : function (s,c,p) {\n    return s + c * ((p - 1) * (p - 1) * (p - 1) + 1);\n  },\n  'linear' : function (s,c,p) {\n    return s + c * p;\n  }\n}\nmodule.exports = eases;\n\n},{}],3:[function(require,module,exports){\n/**\n *  Function: os.getPageOffset\n *  gets the page offset top and left of a DOM element\n */\nmodule.exports = function getPageOffset (element) {\n  if (!element) {\n    void 0;\n  }\n  var pageOffsetX = element.offsetLeft,\n  pageOffsetY = element.offsetTop;\n\n  while (element = element.offsetParent) {\n    pageOffsetX += element.offsetLeft;\n    pageOffsetY += element.offsetTop;\n  }\n\n  return {\n    left : pageOffsetX,\n    top : pageOffsetY\n  }\n}\n\n},{}],4:[function(require,module,exports){\n/**\n *  getScrollPos\n *\n *  cross browser way to get scrollTop\n */\nmodule.exports = (function (undefined) {\n  if (window.scrollY !== undefined)\n    return function getScrollPos () { return window.scrollY; }\n  else\n    return function getScrollPos () { return document.documentElement.scrollTop; }\n})();\n\n},{}],5:[function(require,module,exports){\n/**\n *  get window size, cross browser friendly\n *  call .width() or .height() to get the relevant value in pixels\n */\nvar windowHeight = function windowHeight () {\n  return window.innerHeight || document.documentElement.clientHeight;\n};\nvar windowWidth = function windowWidth () {\n  return window.innerWidth || document.documentElement.clientWidth;\n};\n\nmodule.exports = {\n  width: windowWidth,\n  height: windowHeight\n}\n\n},{}],6:[function(require,module,exports){\n/**\n *  Loop\n *\n *  The requestAnimationFrame Loop. It handles animation and state changes\n *  related to scrolling or window sizing. It can also be used for regular js\n *  driven animation as well.\n *\n *  To use:\n *    exports.addScrollFunction(fn) - adds a function to fire whenever scroll\n *      position changes\n *    exports.addResizeFunction(fn) - adds a function to fire whenever the\n *      window is resized, debounced by the value of the resizeDebounce var\n *    exports.addFunction(fn) - adds a function to fire on every iteration of\n *      the loop. Limit the use of this\n *    exports.removeFunction(fn) - removes a function from the list of functions\n *      to fire\n *    exports.start() - starts the loop (doesn't need to be called unless the\n *      loop was stopped at some point)\n *    exports.stop() - stops the loop\n *    exports.force() - forces the next iteration of the loop to fire scroll and\n *      resize functions, regardless of whether or not either things actually\n *      happened\n */\n\n/**\n * Provides requestAnimationFrame in a cross browser way.\n * @author paulirish / http://paulirish.com/\n */\nif ( !window.requestAnimationFrame ) {\n\twindow.requestAnimationFrame = ( function() {\n\t\treturn window.webkitRequestAnimationFrame ||\n\t\twindow.mozRequestAnimationFrame ||\n\t\twindow.oRequestAnimationFrame ||\n\t\twindow.msRequestAnimationFrame ||\n\t\tfunction( /* function FrameRequestCallback */ callback ) {\n\t\t\twindow.setTimeout( callback, 1000 / 60 );\n\t\t};\n\t} )();\n}\n\n;(function (document,window,undefined) {\n\n  // other lib helpers\n  var getScrollPos = require('lib/getScrollPos');\n\n  // private vars\n  var running = true,\n      lastBodyWidth = document.body.offsetWidth, // store width to determine if resize needed\n      lastBodyHeight = document.body.offsetHeight, // store height to determine if resize needed\n      lastScroll = -1,\n      lastTime = new Date().getTime(), // last time so we know how long it's been\n      resizeDebounce = 500\n      ;\n\n  // save the functions the loop should run\n  // will be passed currentTime, timeChange\n  var loopFuncs = {\n    resize : [], // functions to run on resize\n    scroll : [], // functions to run on scroll\n    tick : [] // functions to run every tick\n  };\n\n  // add/remove methods for those functions\n  var addLoopFunction = function addLoopFunction (type, fn) {\n    if (loopFuncs[type].indexOf(fn) === -1) { // make sure it doesn't already exist (only works with non-anonymous functions)\n      loopFuncs[type].push(fn);\n\t\t\tstart();\n      return true;\n    }\n    return false;\n  }\n  var addScrollFunction = function addScrollFunction (fn) {\n    return addLoopFunction('scroll',fn);\n  }\n  var addResizeFunction = function addResizeFunction (fn) {\n    return addLoopFunction('resize',fn);\n  }\n  var addFunction = function addFunction (fn) {\n    return addLoopFunction('tick',fn);\n  }\n  var removeFunction = function removeFunction (fn) {\n    var types = ['resize','scroll','tick'];\n    var found = false;\n    for (var i = 0; i < types.length; i++) {\n      var index = loopFuncs[types[i]].indexOf(fn);\n      if (index !== -1) {\n        loopFuncs[types[i]].splice(index,1);\n        found = true;\n        break;\n      }\n    }\n\t\t// check that we're still listening\n    for (var i = 0; i < types.length; i++) {\n\t\t\tif (loopFuncs[types[i]].length)\n\t\t\t\tbreak;\n\t\t\telse if (i === types.length - 1)\n\t\t\t\tstop();\n\t\t}\n    return found;\n  }\n\n  // do all functions of a given type\n  var doLoopFunctions = function doLoopFunctions (type,currentTime) {\n    for (var i = 0, len = loopFuncs[type].length; i < len; i++) {\n\t\t\tif (loopFuncs[type][i]) // extra check for safety\n      \tloopFuncs[type][i].call(window,currentTime);\n    }\n  }\n\n  // start/stop control\n  var start = function startLoop () {\n    running = true;\n\t\tloopFn();\n  }\n  var stop = function stopLoop () {\n    running = false;\n  }\n\n  // force it to fire next time through by setting lastScroll and lastBodyWidth\n  // to impossible values\n  var force = function forceLoop () {\n    lastBodyWidth = -1;\n    lastScroll = -1;\n  }\n\n  // hold a resize timout so we can debounce it\n  var resizeTimeout = null;\n\n  // the real deal!\n  // in a closure for maximum safety, and so it autostarts\n  // note: after checking using jsperf, rather than making one big todo array of\n  // all the functions, it's faster to call each array of functions separately\n  function loopFn() {\n\n    // check that we're actually running...\n    if (running) {\n\n      var currentTime = new Date().getTime();\n      var timeChange = currentTime - lastTime;\n      var currentScroll = getScrollPos();\n\n      // check if resize\n      if (document.body.offsetWidth !== lastBodyWidth || document.body.offsetHeight !== lastBodyHeight) {\n        // resize is true, save new sizes\n        lastBodyWidth = document.body.offsetWidth;\n        lastBodyHeight = document.body.offsetHeight;\n\n        if (resizeTimeout)\n          window.clearTimeout(resizeTimeout);\n        resizeTimeout = window.setTimeout(function () {\n          doLoopFunctions('resize',currentTime);\n        }, resizeDebounce);\n      }\n\n      // check if scroll\n      if (lastScroll !== currentScroll) {\n        // scroll is true, save new position\n        lastScroll = currentScroll;\n\n        // call each function\n        doLoopFunctions('scroll',currentTime);\n      }\n\n      // do the always functions\n      doLoopFunctions('tick',currentTime);\n\n      // save the new time\n      lastTime = currentTime;\n\n\t\t\t// make sure we do the tick again next time\n\t    requestAnimationFrame(loopFn);\n    }\n  };\n\n  // export the useful functions\n  module.exports = {\n    addScrollFunction: addScrollFunction,\n    addResizeFunction: addResizeFunction,\n    addFunction: addFunction,\n    removeFunction: removeFunction,\n    start: start,\n    stop: stop,\n    force: force\n  }\n\n})(document,window);\n\n},{\"lib/getScrollPos\":4}],7:[function(require,module,exports){\n/**\n *  Useful class for handling parallaxing things\n *  Stores object measurements and returns percentage of scroll when asked\n */\n\n// helpers\nvar getPageOffset = require('lib/getPageOffset'),\n    windowSize = require('lib/getWindowSize'),\n    getScrollPos = require('lib/getScrollPos'),\n    loop = require('lib/loop')\n    ;\n\n\nvar Parallax = function Parallax (element, onScroll) {\n  if (!this instanceof Parallax)\n    return new Parallax(element);\n\n  var _this = this;\n  this.element = element;\n\n  // get measurements immediately\n  this.measure();\n  if (onScroll)\n    onScroll(_this.getPercentage());\n\n  // listeners\n  this.onResize = function measureParallax () {\n    _this.measure();\n  }\n  if (onScroll) {\n    this.onScroll = function scrollParallax () {\n      onScroll(_this.getPercentage());\n    }\n  }\n\n  // start 'er up\n  this.enable();\n}\nParallax.prototype = {\n  measure: function () {\n    var po = getPageOffset(this.element);\n    this.top = po.top - windowSize.height();\n    this.bottom = po.top + this.element.offsetHeight;\n    this.height = this.bottom - this.top;\n  },\n  getPercentage: function () {\n    var scrollY = getScrollPos();\n    var perc = (scrollY - this.top) / (this.height);\n    return perc;\n  },\n  disable: function () {\n    loop.removeFunction(this.onResize);\n    if (this.onScroll)\n      loop.removeFunction(this.onScroll);\n  },\n  enable: function () {\n    loop.addResizeFunction(this.onResize);\n    if (this.onScroll)\n      loop.addScrollFunction(this.onScroll);\n  },\n  destroy: function () {\n    this.disable();\n    delete this;\n  }\n}\n\nmodule.exports = Parallax;\n\n},{\"lib/getPageOffset\":3,\"lib/getScrollPos\":4,\"lib/getWindowSize\":5,\"lib/loop\":6}],8:[function(require,module,exports){\n/**\n *  Sets Transform styles cross browser\n *  @param {HTMLElement}\n *  @param {string} value of the transform style\n */\n\nvar transformAttributes = ['transform','webkitTransform','mozTransform','msTransform'];\nvar setTransform = function (element, transformString) {\n  for (var i = 0, len = transformAttributes.length; i < len; i++) {\n    element.style[transformAttributes[i]] = transformString;\n  }\n}\n\nmodule.exports = setTransform;\n\n},{}],9:[function(require,module,exports){\n/**\r\n *  Full Article controller\r\n */\r\n\r\n// requirements\r\nvar Halftone = require('objects/halftone');\r\n\r\n// settings\r\nvar HEADER_HALFTONE_SETTINGS = {\r\n  fade: 12\r\n}\r\nvar INNER_HALFTONE_SETTINGS = {\r\n  fade: 0,\r\n  imageSizing: 'contain',\r\n  inEaseStart: .1, // scroll percentage to start animation in on first dot\r\n  inEaseEnd: .5, // scroll percentage to end animation in on last dot\r\n  cornering: 4\r\n}\r\n\r\n/**\r\n *  Article class\r\n *  @param {HTMLElement} the whole damn article\r\n */\r\nvar Article = function (element) {\r\n  this.element = element;\r\n\r\n  // init header\r\n  var headerEl = element.querySelector('.article__header');\r\n  if (headerEl) {\r\n    this.header = new Halftone(headerEl, HEADER_HALFTONE_SETTINGS);\r\n    this.header.animIn(1200);\r\n  }\r\n\r\n  // init other halftones\r\n  var halftoneEls = element.querySelectorAll('.halftone');\r\n  this.halftones = [];\r\n  for (var i = 0, len = halftoneEls.length; i < len; i++) {\r\n    var ht = new Halftone(halftoneEls[i], INNER_HALFTONE_SETTINGS);\r\n    //ht.animIn(1200);\r\n    this.halftones.push(ht);\r\n  }\r\n}\r\n\r\n// temp init article\r\nwindow.article = new Article(document.querySelector('.article'));\r\n\n},{\"objects/halftone\":10}],10:[function(require,module,exports){\n/**\r\n *  Controls cool halftone thingies\r\n */\r\n\r\n// requirements\r\nvar eases = require('lib/ease');\r\nvar ScrollController = require('lib/scrollController');\r\nvar setTransform = require('lib/setTransform');\r\nvar windowSize = require('lib/getWindowSize');\r\nvar getBreakpoint = require('lib/breakpoints');\r\nvar loop = require('lib/loop');\r\n\r\n// settings\r\nvar DEFAULTS = {\r\n  fade: 4, // rows to fade top and bottom, if 0 the canvas is sized to be contained instead of overflow on the sides\r\n  maxRadius: 15, // maximum radius for a dot\r\n  inEaseFn: eases.easeOut,\r\n  inEaseStart: .2, // scroll percentage to start animation in on first dot\r\n  inEaseEnd: .8, // scroll percentage to end animation in on last dot\r\n  outEaseFn: eases.linear,\r\n  outEaseStart: .6, // scroll percentage to start animation out on first dot\r\n  outEaseEnd: 1.1, // scroll percentage to end animation out on last dot\r\n  fixed: false, // fixed position and full screen?\r\n  imageSizing: 'cover', // 'cover' or 'contain'\r\n  cornering: 0, // diagnal top left fade\r\n  control: 'scroll' // 'scroll', 'mouse' (TODO), or 'none'\r\n}\r\n\r\n/**\r\n *  Dot class\r\n *  @param {int} grid position X\r\n *  @param {int} grid position Y\r\n *  @param {Number} max radius\r\n *  @param {Halftone} parent halftone object\r\n *\r\n *  @method draw ({canvas context})\r\n *  @method setRadiusByPercentage ({percent of max radius})\r\n */\r\nvar Dot = function (gridX, gridY, maxRadius, parent) {\r\n  this.gridX = gridX;\r\n  this.gridY = gridY;\r\n  this.maxRadius = maxRadius;\r\n  this.radius = maxRadius;\r\n  this.parent = parent;\r\n  this.percentage = (this.gridX + this.gridY) / (this.parent.columns + this.parent.rows);\r\n\r\n  // define location within canvas context\r\n  this.x = this.gridX * this.parent.settings.maxRadius;\r\n  this.y = this.gridY * this.parent.settings.maxRadius;\r\n  if (this.parent.settings.fade)\r\n    this.y += this.parent.settings.maxRadius;\r\n\r\n  // handle cornering\r\n  if (this.parent.settings.cornering && this.gridX + this.gridY <= this.parent.settings.cornering + 1) {\r\n    this.maxRadius = eases.linear(.33,.66,(this.gridX + this.gridY) / (this.parent.settings.cornering + 1)) * this.maxRadius;\r\n    this.radius = this.maxRadius;\r\n  }\r\n  else if (this.parent.settings.cornering && -1 * ((this.gridX + this.gridY) - (this.parent.columns + this.parent.rows - 2)) <= this.parent.settings.cornering + 1) {\r\n    this.maxRadius = eases.linear(.33,.66,-1 * ((this.gridX + this.gridY) - (this.parent.columns + this.parent.rows - 2)) / (this.parent.settings.cornering + 1)) * this.maxRadius;\r\n    this.radius = this.maxRadius;\r\n  }\r\n}\r\nDot.prototype = {\r\n  draw: function (ctx) {\r\n    ctx.moveTo(this.x, this.y - this.radius);\r\n    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);\r\n  },\r\n  setRadiusByPercentage: function (percent) {\r\n    this.radius = Math.max(0, Math.min(this.maxRadius, percent * this.maxRadius));\r\n  }\r\n}\r\n\r\n/**\r\n *  Halftone class\r\n *  @param {HTMLElement} element, optionally with a background image, to turn into the toy\r\n *  @param {object} settings that can override DEFAULTS defined above\r\n *\r\n *  @method draw({percentage of animation progress})\r\n *  @method createCanvas()\r\n *  @method sizeImage() - for internal use\r\n *  @method getPercentageFromScroll() - returns a percentage of progress past element based on scrolling\r\n *  @method init()\r\n *  @method destroy()\r\n *  @method animIn({animation time in ms})\r\n */\r\nvar Halftone = function (element, settings) {\r\n  this.element = element;\r\n  this.settings = {};\r\n  settings = settings || {};\r\n  for (var prop in DEFAULTS) {\r\n    this.settings[prop] = settings[prop] !== undefined ? settings[prop] : DEFAULTS[prop];\r\n  }\r\n\r\n  var computedStyle = getComputedStyle(this.element);\r\n  // make sure positioning is valid\r\n  if (computedStyle.position === 'static') {\r\n    this.element.style.position = 'relative';\r\n  }\r\n  // set up color and image\r\n  this.fill = computedStyle.backgroundColor;\r\n  if (!!computedStyle.backgroundImage && computedStyle.backgroundImage !== 'none') {\r\n    this.image = new Image();\r\n    this.image.src = computedStyle.backgroundImage.match(/\\((?:'|\")?(.+?)(?:'|\")?\\)/)[1];\r\n  }\r\n  this.element.style.background = 'none';\r\n\r\n  // listeners\r\n  var _this = this;\r\n  this.onResize = function () {\r\n    _this.createCanvas();\r\n  }\r\n  this.onScroll = function (percentage) {\r\n    _this.draw(percentage);\r\n  }\r\n\r\n  // autostart\r\n  this.init();\r\n}\r\nHalftone.prototype = {\r\n  draw: function (percentage) {\r\n    if (!this.canvas || (percentage < this.settings.inEaseStart || percentage > this.settings.outEaseEnd)) {\r\n      return false;\r\n    }\r\n    // clear current crap\r\n    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n    this.ctx.save();\r\n    this.ctx.beginPath();\r\n    // handle animation\r\n    // in vars\r\n    var effectiveInPerc = (percentage - this.settings.inEaseStart) / (this.settings.inEaseEnd - this.settings.inEaseStart);\r\n    effectiveInPerc = effectiveInPerc < 1 ? this.settings.inEaseFn(-1,3,effectiveInPerc) : 2;\r\n    // out vars\r\n    var effectiveOutPerc = (percentage - this.settings.outEaseStart) / (this.settings.outEaseEnd - this.settings.outEaseStart);\r\n    effectiveOutPerc = effectiveOutPerc > 0 ? this.settings.outEaseFn(2,-3,effectiveOutPerc) : 2;\r\n\r\n    for (var i = 0, len = this.dots.length; i < len; i++) {\r\n      var dotInPerc = effectiveInPerc - this.dots[i].percentage;\r\n      var dotOutPerc = effectiveOutPerc - (1 - this.dots[i].percentage);\r\n      this.dots[i].setRadiusByPercentage(Math.min(dotInPerc,dotOutPerc));\r\n      this.dots[i].draw(this.ctx);\r\n    }\r\n\r\n    this.ctx.fill();\r\n\r\n    if (this.image && this.imageOffsets) {\r\n      this.ctx.globalCompositeOperation = \"source-atop\";\r\n      this.ctx.drawImage(this.image, this.imageOffsets.x, this.imageOffsets.y, this.imageOffsets.width, this.imageOffsets.height);\r\n    }\r\n    this.ctx.restore();\r\n  },\r\n  createCanvas: function () {\r\n    // kill existing canvas\r\n    if (this.canvas) {\r\n      this.canvas.remove();\r\n    }\r\n    // create new canvas and dots\r\n    this.canvas = document.createElement('canvas');\r\n    this.canvas.setAttribute('class','canvas-halftone');\r\n    if (!this.settings.fixed || getBreakpoint() < 3) {\r\n      // normal sizing and positioning\r\n      var columns = Math.floor(this.element.offsetWidth / this.settings.maxRadius);\r\n      var rows = Math.floor(this.element.offsetHeight / this.settings.maxRadius);\r\n      if (this.settings.fade) {\r\n        columns += 2;\r\n        rows += this.settings.fade * 2 + 2;\r\n      }\r\n      else {\r\n        if (columns % 2 === 0)\r\n          columns += 1;\r\n        if (rows % 2 === 0)\r\n          rows += 1;\r\n      }\r\n    }\r\n    else {\r\n      // fixed sizing and positioning\r\n      var columns = Math.floor(windowSize.width() / this.settings.maxRadius) + 2;\r\n      var rows = Math.floor(windowSize.height() / this.settings.maxRadius) + this.settings.fade * 2 + 2;\r\n      setTransform(this.element,'none');\r\n      setTransform(this.canvas,'none');\r\n      this.canvas.style.position = 'fixed';\r\n      this.canvas.style.top = this.settings.fade * this.settings.maxRadius * -1 + 'px';\r\n      this.canvas.style.left = 0;\r\n    }\r\n    this.canvas.width = (columns - 1) * this.settings.maxRadius;\r\n    this.canvas.height = (this.settings.fade ? rows + 1 : rows - 1) * this.settings.maxRadius;\r\n    this.ctx = this.canvas.getContext('2d');\r\n    this.ctx.fillStyle = this.fill;\r\n    this.columns = columns;\r\n    this.rows = rows;\r\n\r\n    // define the dots\r\n    this.dots = [];\r\n    for (var y = 0; y < rows; y++) {\r\n      for (var x = 0; x < columns; x+= 2) {\r\n        var rad;\r\n        if (y < this.settings.fade) {\r\n          rad = (y + 1) / (this.settings.fade + 1) * this.settings.maxRadius;\r\n        }\r\n        else if (y >= rows - this.settings.fade) {\r\n          rad = -1 * (y + 1 - rows) / (this.settings.fade + 1) * this.settings.maxRadius;\r\n        }\r\n        else if (!this.settings.fade && y === 0 && x === 0 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else if (!this.settings.fade && y === 0 && x === columns - 1 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else if (!this.settings.fade && y === rows - 1 && x === 0 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else if (!this.settings.fade && y === rows - 1 && x === columns - 1 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else {\r\n          rad = this.settings.maxRadius;\r\n        }\r\n        this.dots.push(new Dot(y % 2 ? x + 1 : x, y, rad, this));\r\n      }\r\n    }\r\n\r\n    this.element.appendChild(this.canvas);\r\n\r\n    // determine image size\r\n    if (this.image) {\r\n      if (this.image.complete) {\r\n        this.sizeImage();\r\n      }\r\n      else {\r\n        var _this = this;\r\n        this.image.onload = function () {\r\n          _this.sizeImage();\r\n          _this.draw(_this.getPercentageFromScroll());\r\n        }\r\n      }\r\n    }\r\n\r\n    // establish scroll based controls only if screen is large enough for us to care\r\n    if (getBreakpoint() >= 3 && this.settings.control === 'scroll') {\r\n      this.scrollController = new ScrollController(this.element, this.onScroll);\r\n    }\r\n    else {\r\n      if (this.scrollController)\r\n        this.scrollController.destroy();\r\n      this.draw(this.getPercentageFromScroll());\r\n    }\r\n  },\r\n  sizeImage: function () {\r\n    var scale = this.canvas.width / this.image.width;\r\n    if (this.settings.imageSizing === 'cover' && scale * this.image.height < this.canvas.height) {\r\n      scale = this.canvas.height / this.image.height;\r\n    }\r\n    else if (this.settings.imageSizing === 'contain' && scale * this.image.height > this.canvas.height) {\r\n      scale = this.canvas.height / this.image.height;\r\n    }\r\n    //this.imageScale = scale;\r\n    this.imageOffsets = {\r\n      x: (this.canvas.width - this.image.width * scale) / 2,\r\n      y: (this.canvas.height - this.image.height * scale) / 2,\r\n      width: this.image.width * scale,\r\n      height: this.image.height * scale\r\n    }\r\n  },\r\n  getPercentageFromScroll: function () {\r\n    return this.scrollController ? this.scrollController.getPercentage() : .55;\r\n  },\r\n  init: function () {\r\n    // make the canvas\r\n    this.createCanvas();\r\n\r\n    // scroll listener added in createCanvas fn\r\n\r\n    // listen for resize\r\n    loop.addResizeFunction(this.onResize);\r\n  },\r\n  destroy: function () {\r\n    if (this.scrollController)\r\n      this.scrollController.destroy();\r\n    loop.removeFunction(this.onResize);\r\n    this.canvas.remove();\r\n    delete this;\r\n  },\r\n  anim: function (startPerc, endPerc, time, ease, cb) {\r\n    // first, turn off scroll listening\r\n    if (this.scrollController)\r\n      this.scrollController.disable();\r\n    // establish defaults\r\n    startPerc = startPerc || 0;\r\n    endPerc = endPerc || 1;\r\n    time = time || 1000;\r\n    ease = ease || eases.easeInOut;\r\n    // get some base vars\r\n    var startTime = new Date().getTime();\r\n    var deltaPerc = endPerc - startPerc;\r\n    var _this = this;\r\n    var running = true;\r\n    // this goes in the loop\r\n    var animationFn = function () {\r\n      if (running) {\r\n        var now = new Date().getTime();\r\n        var deltaTime = (now - startTime) / time;\r\n        if (deltaTime < 1)\r\n          _this.draw(ease(startPerc,deltaPerc,deltaTime));\r\n        else {\r\n          running = false;\r\n          _this.draw(endPerc);\r\n          if (_this.scrollController)\r\n            _this.scrollController.enable();\r\n          // get back out of the loop\r\n          loop.removeFunction(animationFn);\r\n          if (cb)\r\n            cb();\r\n        }\r\n      }\r\n    }\r\n    loop.addFunction(animationFn);\r\n  },\r\n  animIn: function (time, cb) {\r\n    // animate the canvas from inEaseStart to current scroll pos\r\n    // check if we even need to\r\n    var endPerc = this.getPercentageFromScroll();\r\n    if (endPerc < this.settings.inEaseStart)\r\n      return false;\r\n\r\n    this.anim(this.settings.inEaseStart, endPerc, time, eases.easeOut, cb);\r\n  },\r\n  animOut: function (time, cb) {\r\n    // animate the canvas from inEaseStart to current scroll pos\r\n    // check if we even need to\r\n    var startPerc = this.getPercentageFromScroll();\r\n    if (startPerc < this.settings.inEaseStart)\r\n      return false;\r\n\r\n    this.anim(startPerc, this.settings.inEaseStart, time, eases.easeIn, cb);\r\n  }\r\n}\r\n\r\n// temp auto init\r\n// var htrEls = document.querySelectorAll('.halftone');\r\n// var htrs = [];\r\n// for (var i = 0, len = htrEls.length; i < len; i++) {\r\n//   htrs.push(new Halftone(htrEls[i], { fade: 12, fixed: false }));\r\n// }\r\n// window.htrs = htrs;\r\nmodule.exports = Halftone;\r\n\n},{\"lib/breakpoints\":1,\"lib/ease\":2,\"lib/getWindowSize\":5,\"lib/loop\":6,\"lib/scrollController\":7,\"lib/setTransform\":8}],11:[function(require,module,exports){\n/**\n *  scripts.js\n *  This should include objects, which in turn include the lib files they need.\n *  This keeps us using a modular approach to dev while also only including the\n *  parts of the library we need.\n */\n// objects\nrequire('objects/article');\n\n},{\"objects/article\":9}]},{},[11])\n\n","// a bunch of easing functions for making animations\n// all accept start, change, and percent\n\nvar eases = {\n  'easeInOut' : function (s,c,p) {\n    if (p < .5) {\n      return s + c * (2 * p * p);\n    }\n    else {\n      return s + c * (-2 * (p - 1) * (p - 1) + 1);\n    }\n  },\n  'easeIn' : function (s,c,p) {\n    return s + c * p * p;\n  },\n  'easeInCubic' : function (s,c,p) {\n    return s + c * (p * p * p);\n  },\n  'easeOut' : function (s,c,p) {\n    return s + c * (-1 * (p - 1) * (p - 1) + 1);\n  },\n  'easeOutCubic' : function (s,c,p) {\n    return s + c * ((p - 1) * (p - 1) * (p - 1) + 1);\n  },\n  'linear' : function (s,c,p) {\n    return s + c * p;\n  }\n}\nmodule.exports = eases;\n","/**\n *  Function: os.getPageOffset\n *  gets the page offset top and left of a DOM element\n */\nmodule.exports = function getPageOffset (element) {\n  if (!element) {\n    console.error('getPageOffset passed an invalid element:', element);\n  }\n  var pageOffsetX = element.offsetLeft,\n  pageOffsetY = element.offsetTop;\n\n  while (element = element.offsetParent) {\n    pageOffsetX += element.offsetLeft;\n    pageOffsetY += element.offsetTop;\n  }\n\n  return {\n    left : pageOffsetX,\n    top : pageOffsetY\n  }\n}\n","/**\n *  getScrollPos\n *\n *  cross browser way to get scrollTop\n */\nmodule.exports = (function (undefined) {\n  if (window.scrollY !== undefined)\n    return function getScrollPos () { return window.scrollY; }\n  else\n    return function getScrollPos () { return document.documentElement.scrollTop; }\n})();\n","/**\n *  get window size, cross browser friendly\n *  call .width() or .height() to get the relevant value in pixels\n */\nvar windowHeight = function windowHeight () {\n  return window.innerHeight || document.documentElement.clientHeight;\n};\nvar windowWidth = function windowWidth () {\n  return window.innerWidth || document.documentElement.clientWidth;\n};\n\nmodule.exports = {\n  width: windowWidth,\n  height: windowHeight\n}\n","/**\n *  Loop\n *\n *  The requestAnimationFrame Loop. It handles animation and state changes\n *  related to scrolling or window sizing. It can also be used for regular js\n *  driven animation as well.\n *\n *  To use:\n *    exports.addScrollFunction(fn) - adds a function to fire whenever scroll\n *      position changes\n *    exports.addResizeFunction(fn) - adds a function to fire whenever the\n *      window is resized, debounced by the value of the resizeDebounce var\n *    exports.addFunction(fn) - adds a function to fire on every iteration of\n *      the loop. Limit the use of this\n *    exports.removeFunction(fn) - removes a function from the list of functions\n *      to fire\n *    exports.start() - starts the loop (doesn't need to be called unless the\n *      loop was stopped at some point)\n *    exports.stop() - stops the loop\n *    exports.force() - forces the next iteration of the loop to fire scroll and\n *      resize functions, regardless of whether or not either things actually\n *      happened\n */\n\n/**\n * Provides requestAnimationFrame in a cross browser way.\n * @author paulirish / http://paulirish.com/\n */\nif ( !window.requestAnimationFrame ) {\n\twindow.requestAnimationFrame = ( function() {\n\t\treturn window.webkitRequestAnimationFrame ||\n\t\twindow.mozRequestAnimationFrame ||\n\t\twindow.oRequestAnimationFrame ||\n\t\twindow.msRequestAnimationFrame ||\n\t\tfunction( /* function FrameRequestCallback */ callback ) {\n\t\t\twindow.setTimeout( callback, 1000 / 60 );\n\t\t};\n\t} )();\n}\n\n;(function (document,window,undefined) {\n\n  // other lib helpers\n  var getScrollPos = require('lib/getScrollPos');\n\n  // private vars\n  var running = true,\n      lastBodyWidth = document.body.offsetWidth, // store width to determine if resize needed\n      lastBodyHeight = document.body.offsetHeight, // store height to determine if resize needed\n      lastScroll = -1,\n      lastTime = new Date().getTime(), // last time so we know how long it's been\n      resizeDebounce = 500\n      ;\n\n  // save the functions the loop should run\n  // will be passed currentTime, timeChange\n  var loopFuncs = {\n    resize : [], // functions to run on resize\n    scroll : [], // functions to run on scroll\n    tick : [] // functions to run every tick\n  };\n\n  // add/remove methods for those functions\n  var addLoopFunction = function addLoopFunction (type, fn) {\n    if (loopFuncs[type].indexOf(fn) === -1) { // make sure it doesn't already exist (only works with non-anonymous functions)\n      loopFuncs[type].push(fn);\n\t\t\tstart();\n      return true;\n    }\n    return false;\n  }\n  var addScrollFunction = function addScrollFunction (fn) {\n    return addLoopFunction('scroll',fn);\n  }\n  var addResizeFunction = function addResizeFunction (fn) {\n    return addLoopFunction('resize',fn);\n  }\n  var addFunction = function addFunction (fn) {\n    return addLoopFunction('tick',fn);\n  }\n  var removeFunction = function removeFunction (fn) {\n    var types = ['resize','scroll','tick'];\n    var found = false;\n    for (var i = 0; i < types.length; i++) {\n      var index = loopFuncs[types[i]].indexOf(fn);\n      if (index !== -1) {\n        loopFuncs[types[i]].splice(index,1);\n        found = true;\n        break;\n      }\n    }\n\t\t// check that we're still listening\n    for (var i = 0; i < types.length; i++) {\n\t\t\tif (loopFuncs[types[i]].length)\n\t\t\t\tbreak;\n\t\t\telse if (i === types.length - 1)\n\t\t\t\tstop();\n\t\t}\n    return found;\n  }\n\n  // do all functions of a given type\n  var doLoopFunctions = function doLoopFunctions (type,currentTime) {\n    for (var i = 0, len = loopFuncs[type].length; i < len; i++) {\n\t\t\tif (loopFuncs[type][i]) // extra check for safety\n      \tloopFuncs[type][i].call(window,currentTime);\n    }\n  }\n\n  // start/stop control\n  var start = function startLoop () {\n    running = true;\n\t\tloopFn();\n  }\n  var stop = function stopLoop () {\n    running = false;\n  }\n\n  // force it to fire next time through by setting lastScroll and lastBodyWidth\n  // to impossible values\n  var force = function forceLoop () {\n    lastBodyWidth = -1;\n    lastScroll = -1;\n  }\n\n  // hold a resize timout so we can debounce it\n  var resizeTimeout = null;\n\n  // the real deal!\n  // in a closure for maximum safety, and so it autostarts\n  // note: after checking using jsperf, rather than making one big todo array of\n  // all the functions, it's faster to call each array of functions separately\n  function loopFn() {\n\n    // check that we're actually running...\n    if (running) {\n\n      var currentTime = new Date().getTime();\n      var timeChange = currentTime - lastTime;\n      var currentScroll = getScrollPos();\n\n      // check if resize\n      if (document.body.offsetWidth !== lastBodyWidth || document.body.offsetHeight !== lastBodyHeight) {\n        // resize is true, save new sizes\n        lastBodyWidth = document.body.offsetWidth;\n        lastBodyHeight = document.body.offsetHeight;\n\n        if (resizeTimeout)\n          window.clearTimeout(resizeTimeout);\n        resizeTimeout = window.setTimeout(function () {\n          doLoopFunctions('resize',currentTime);\n        }, resizeDebounce);\n      }\n\n      // check if scroll\n      if (lastScroll !== currentScroll) {\n        // scroll is true, save new position\n        lastScroll = currentScroll;\n\n        // call each function\n        doLoopFunctions('scroll',currentTime);\n      }\n\n      // do the always functions\n      doLoopFunctions('tick',currentTime);\n\n      // save the new time\n      lastTime = currentTime;\n\n\t\t\t// make sure we do the tick again next time\n\t    requestAnimationFrame(loopFn);\n    }\n  };\n\n  // export the useful functions\n  module.exports = {\n    addScrollFunction: addScrollFunction,\n    addResizeFunction: addResizeFunction,\n    addFunction: addFunction,\n    removeFunction: removeFunction,\n    start: start,\n    stop: stop,\n    force: force\n  }\n\n})(document,window);\n","/**\n *  Useful class for handling parallaxing things\n *  Stores object measurements and returns percentage of scroll when asked\n */\n\n// helpers\nvar getPageOffset = require('lib/getPageOffset'),\n    windowSize = require('lib/getWindowSize'),\n    getScrollPos = require('lib/getScrollPos'),\n    loop = require('lib/loop')\n    ;\n\n\nvar Parallax = function Parallax (element, onScroll) {\n  if (!this instanceof Parallax)\n    return new Parallax(element);\n\n  var _this = this;\n  this.element = element;\n\n  // get measurements immediately\n  this.measure();\n  if (onScroll)\n    onScroll(_this.getPercentage());\n\n  // listeners\n  this.onResize = function measureParallax () {\n    _this.measure();\n  }\n  if (onScroll) {\n    this.onScroll = function scrollParallax () {\n      onScroll(_this.getPercentage());\n    }\n  }\n\n  // start 'er up\n  this.enable();\n}\nParallax.prototype = {\n  measure: function () {\n    var po = getPageOffset(this.element);\n    this.top = po.top - windowSize.height();\n    this.bottom = po.top + this.element.offsetHeight;\n    this.height = this.bottom - this.top;\n  },\n  getPercentage: function () {\n    var scrollY = getScrollPos();\n    var perc = (scrollY - this.top) / (this.height);\n    return perc;\n  },\n  disable: function () {\n    loop.removeFunction(this.onResize);\n    if (this.onScroll)\n      loop.removeFunction(this.onScroll);\n  },\n  enable: function () {\n    loop.addResizeFunction(this.onResize);\n    if (this.onScroll)\n      loop.addScrollFunction(this.onScroll);\n  },\n  destroy: function () {\n    this.disable();\n    delete this;\n  }\n}\n\nmodule.exports = Parallax;\n","/**\n *  Sets Transform styles cross browser\n *  @param {HTMLElement}\n *  @param {string} value of the transform style\n */\n\nvar transformAttributes = ['transform','webkitTransform','mozTransform','msTransform'];\nvar setTransform = function (element, transformString) {\n  for (var i = 0, len = transformAttributes.length; i < len; i++) {\n    element.style[transformAttributes[i]] = transformString;\n  }\n}\n\nmodule.exports = setTransform;\n","/**\r\n *  Full Article controller\r\n */\r\n\r\n// requirements\r\nvar Halftone = require('objects/halftone');\r\n\r\n// settings\r\nvar HEADER_HALFTONE_SETTINGS = {\r\n  fade: 12\r\n}\r\nvar INNER_HALFTONE_SETTINGS = {\r\n  fade: 0,\r\n  imageSizing: 'contain',\r\n  inEaseStart: .1, // scroll percentage to start animation in on first dot\r\n  inEaseEnd: .5, // scroll percentage to end animation in on last dot\r\n  cornering: 4\r\n}\r\n\r\n/**\r\n *  Article class\r\n *  @param {HTMLElement} the whole damn article\r\n */\r\nvar Article = function (element) {\r\n  this.element = element;\r\n\r\n  // init header\r\n  var headerEl = element.querySelector('.article__header');\r\n  if (headerEl) {\r\n    this.header = new Halftone(headerEl, HEADER_HALFTONE_SETTINGS);\r\n    this.header.animIn(1200);\r\n  }\r\n\r\n  // init other halftones\r\n  var halftoneEls = element.querySelectorAll('.halftone');\r\n  this.halftones = [];\r\n  for (var i = 0, len = halftoneEls.length; i < len; i++) {\r\n    var ht = new Halftone(halftoneEls[i], INNER_HALFTONE_SETTINGS);\r\n    //ht.animIn(1200);\r\n    this.halftones.push(ht);\r\n  }\r\n}\r\n\r\n// temp init article\r\nwindow.article = new Article(document.querySelector('.article'));\r\n","/**\r\n *  Controls cool halftone thingies\r\n */\r\n\r\n// requirements\r\nvar eases = require('lib/ease');\r\nvar ScrollController = require('lib/scrollController');\r\nvar setTransform = require('lib/setTransform');\r\nvar windowSize = require('lib/getWindowSize');\r\nvar getBreakpoint = require('lib/breakpoints');\r\nvar loop = require('lib/loop');\r\n\r\n// settings\r\nvar DEFAULTS = {\r\n  fade: 4, // rows to fade top and bottom, if 0 the canvas is sized to be contained instead of overflow on the sides\r\n  maxRadius: 15, // maximum radius for a dot\r\n  inEaseFn: eases.easeOut,\r\n  inEaseStart: .2, // scroll percentage to start animation in on first dot\r\n  inEaseEnd: .8, // scroll percentage to end animation in on last dot\r\n  outEaseFn: eases.linear,\r\n  outEaseStart: .6, // scroll percentage to start animation out on first dot\r\n  outEaseEnd: 1.1, // scroll percentage to end animation out on last dot\r\n  fixed: false, // fixed position and full screen?\r\n  imageSizing: 'cover', // 'cover' or 'contain'\r\n  cornering: 0, // diagnal top left fade\r\n  control: 'scroll' // 'scroll', 'mouse' (TODO), or 'none'\r\n}\r\n\r\n/**\r\n *  Dot class\r\n *  @param {int} grid position X\r\n *  @param {int} grid position Y\r\n *  @param {Number} max radius\r\n *  @param {Halftone} parent halftone object\r\n *\r\n *  @method draw ({canvas context})\r\n *  @method setRadiusByPercentage ({percent of max radius})\r\n */\r\nvar Dot = function (gridX, gridY, maxRadius, parent) {\r\n  this.gridX = gridX;\r\n  this.gridY = gridY;\r\n  this.maxRadius = maxRadius;\r\n  this.radius = maxRadius;\r\n  this.parent = parent;\r\n  this.percentage = (this.gridX + this.gridY) / (this.parent.columns + this.parent.rows);\r\n\r\n  // define location within canvas context\r\n  this.x = this.gridX * this.parent.settings.maxRadius;\r\n  this.y = this.gridY * this.parent.settings.maxRadius;\r\n  if (this.parent.settings.fade)\r\n    this.y += this.parent.settings.maxRadius;\r\n\r\n  // handle cornering\r\n  if (this.parent.settings.cornering && this.gridX + this.gridY <= this.parent.settings.cornering + 1) {\r\n    this.maxRadius = eases.linear(.33,.66,(this.gridX + this.gridY) / (this.parent.settings.cornering + 1)) * this.maxRadius;\r\n    this.radius = this.maxRadius;\r\n  }\r\n  else if (this.parent.settings.cornering && -1 * ((this.gridX + this.gridY) - (this.parent.columns + this.parent.rows - 2)) <= this.parent.settings.cornering + 1) {\r\n    this.maxRadius = eases.linear(.33,.66,-1 * ((this.gridX + this.gridY) - (this.parent.columns + this.parent.rows - 2)) / (this.parent.settings.cornering + 1)) * this.maxRadius;\r\n    this.radius = this.maxRadius;\r\n  }\r\n}\r\nDot.prototype = {\r\n  draw: function (ctx) {\r\n    ctx.moveTo(this.x, this.y - this.radius);\r\n    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);\r\n  },\r\n  setRadiusByPercentage: function (percent) {\r\n    this.radius = Math.max(0, Math.min(this.maxRadius, percent * this.maxRadius));\r\n  }\r\n}\r\n\r\n/**\r\n *  Halftone class\r\n *  @param {HTMLElement} element, optionally with a background image, to turn into the toy\r\n *  @param {object} settings that can override DEFAULTS defined above\r\n *\r\n *  @method draw({percentage of animation progress})\r\n *  @method createCanvas()\r\n *  @method sizeImage() - for internal use\r\n *  @method getPercentageFromScroll() - returns a percentage of progress past element based on scrolling\r\n *  @method init()\r\n *  @method destroy()\r\n *  @method animIn({animation time in ms})\r\n */\r\nvar Halftone = function (element, settings) {\r\n  this.element = element;\r\n  this.settings = {};\r\n  settings = settings || {};\r\n  for (var prop in DEFAULTS) {\r\n    this.settings[prop] = settings[prop] !== undefined ? settings[prop] : DEFAULTS[prop];\r\n  }\r\n\r\n  var computedStyle = getComputedStyle(this.element);\r\n  // make sure positioning is valid\r\n  if (computedStyle.position === 'static') {\r\n    this.element.style.position = 'relative';\r\n  }\r\n  // set up color and image\r\n  this.fill = computedStyle.backgroundColor;\r\n  if (!!computedStyle.backgroundImage && computedStyle.backgroundImage !== 'none') {\r\n    this.image = new Image();\r\n    this.image.src = computedStyle.backgroundImage.match(/\\((?:'|\")?(.+?)(?:'|\")?\\)/)[1];\r\n  }\r\n  this.element.style.background = 'none';\r\n\r\n  // listeners\r\n  var _this = this;\r\n  this.onResize = function () {\r\n    _this.createCanvas();\r\n  }\r\n  this.onScroll = function (percentage) {\r\n    _this.draw(percentage);\r\n  }\r\n\r\n  // autostart\r\n  this.init();\r\n}\r\nHalftone.prototype = {\r\n  draw: function (percentage) {\r\n    if (!this.canvas || (percentage < this.settings.inEaseStart || percentage > this.settings.outEaseEnd)) {\r\n      return false;\r\n    }\r\n    // clear current crap\r\n    this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n    this.ctx.save();\r\n    this.ctx.beginPath();\r\n    // handle animation\r\n    // in vars\r\n    var effectiveInPerc = (percentage - this.settings.inEaseStart) / (this.settings.inEaseEnd - this.settings.inEaseStart);\r\n    effectiveInPerc = effectiveInPerc < 1 ? this.settings.inEaseFn(-1,3,effectiveInPerc) : 2;\r\n    // out vars\r\n    var effectiveOutPerc = (percentage - this.settings.outEaseStart) / (this.settings.outEaseEnd - this.settings.outEaseStart);\r\n    effectiveOutPerc = effectiveOutPerc > 0 ? this.settings.outEaseFn(2,-3,effectiveOutPerc) : 2;\r\n\r\n    for (var i = 0, len = this.dots.length; i < len; i++) {\r\n      var dotInPerc = effectiveInPerc - this.dots[i].percentage;\r\n      var dotOutPerc = effectiveOutPerc - (1 - this.dots[i].percentage);\r\n      this.dots[i].setRadiusByPercentage(Math.min(dotInPerc,dotOutPerc));\r\n      this.dots[i].draw(this.ctx);\r\n    }\r\n\r\n    this.ctx.fill();\r\n\r\n    if (this.image && this.imageOffsets) {\r\n      this.ctx.globalCompositeOperation = \"source-atop\";\r\n      this.ctx.drawImage(this.image, this.imageOffsets.x, this.imageOffsets.y, this.imageOffsets.width, this.imageOffsets.height);\r\n    }\r\n    this.ctx.restore();\r\n  },\r\n  createCanvas: function () {\r\n    // kill existing canvas\r\n    if (this.canvas) {\r\n      this.canvas.remove();\r\n    }\r\n    // create new canvas and dots\r\n    this.canvas = document.createElement('canvas');\r\n    this.canvas.setAttribute('class','canvas-halftone');\r\n    if (!this.settings.fixed || getBreakpoint() < 3) {\r\n      // normal sizing and positioning\r\n      var columns = Math.floor(this.element.offsetWidth / this.settings.maxRadius);\r\n      var rows = Math.floor(this.element.offsetHeight / this.settings.maxRadius);\r\n      if (this.settings.fade) {\r\n        columns += 2;\r\n        rows += this.settings.fade * 2 + 2;\r\n      }\r\n      else {\r\n        if (columns % 2 === 0)\r\n          columns += 1;\r\n        if (rows % 2 === 0)\r\n          rows += 1;\r\n      }\r\n    }\r\n    else {\r\n      // fixed sizing and positioning\r\n      var columns = Math.floor(windowSize.width() / this.settings.maxRadius) + 2;\r\n      var rows = Math.floor(windowSize.height() / this.settings.maxRadius) + this.settings.fade * 2 + 2;\r\n      setTransform(this.element,'none');\r\n      setTransform(this.canvas,'none');\r\n      this.canvas.style.position = 'fixed';\r\n      this.canvas.style.top = this.settings.fade * this.settings.maxRadius * -1 + 'px';\r\n      this.canvas.style.left = 0;\r\n    }\r\n    this.canvas.width = (columns - 1) * this.settings.maxRadius;\r\n    this.canvas.height = (this.settings.fade ? rows + 1 : rows - 1) * this.settings.maxRadius;\r\n    this.ctx = this.canvas.getContext('2d');\r\n    this.ctx.fillStyle = this.fill;\r\n    this.columns = columns;\r\n    this.rows = rows;\r\n\r\n    // define the dots\r\n    this.dots = [];\r\n    for (var y = 0; y < rows; y++) {\r\n      for (var x = 0; x < columns; x+= 2) {\r\n        var rad;\r\n        if (y < this.settings.fade) {\r\n          rad = (y + 1) / (this.settings.fade + 1) * this.settings.maxRadius;\r\n        }\r\n        else if (y >= rows - this.settings.fade) {\r\n          rad = -1 * (y + 1 - rows) / (this.settings.fade + 1) * this.settings.maxRadius;\r\n        }\r\n        else if (!this.settings.fade && y === 0 && x === 0 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else if (!this.settings.fade && y === 0 && x === columns - 1 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else if (!this.settings.fade && y === rows - 1 && x === 0 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else if (!this.settings.fade && y === rows - 1 && x === columns - 1 && !this.settings.fixed) {\r\n          continue;\r\n        }\r\n        else {\r\n          rad = this.settings.maxRadius;\r\n        }\r\n        this.dots.push(new Dot(y % 2 ? x + 1 : x, y, rad, this));\r\n      }\r\n    }\r\n\r\n    this.element.appendChild(this.canvas);\r\n\r\n    // determine image size\r\n    if (this.image) {\r\n      if (this.image.complete) {\r\n        this.sizeImage();\r\n      }\r\n      else {\r\n        var _this = this;\r\n        this.image.onload = function () {\r\n          _this.sizeImage();\r\n          _this.draw(_this.getPercentageFromScroll());\r\n        }\r\n      }\r\n    }\r\n\r\n    // establish scroll based controls only if screen is large enough for us to care\r\n    if (getBreakpoint() >= 3 && this.settings.control === 'scroll') {\r\n      this.scrollController = new ScrollController(this.element, this.onScroll);\r\n    }\r\n    else {\r\n      if (this.scrollController)\r\n        this.scrollController.destroy();\r\n      this.draw(this.getPercentageFromScroll());\r\n    }\r\n  },\r\n  sizeImage: function () {\r\n    var scale = this.canvas.width / this.image.width;\r\n    if (this.settings.imageSizing === 'cover' && scale * this.image.height < this.canvas.height) {\r\n      scale = this.canvas.height / this.image.height;\r\n    }\r\n    else if (this.settings.imageSizing === 'contain' && scale * this.image.height > this.canvas.height) {\r\n      scale = this.canvas.height / this.image.height;\r\n    }\r\n    //this.imageScale = scale;\r\n    this.imageOffsets = {\r\n      x: (this.canvas.width - this.image.width * scale) / 2,\r\n      y: (this.canvas.height - this.image.height * scale) / 2,\r\n      width: this.image.width * scale,\r\n      height: this.image.height * scale\r\n    }\r\n  },\r\n  getPercentageFromScroll: function () {\r\n    return this.scrollController ? this.scrollController.getPercentage() : .55;\r\n  },\r\n  init: function () {\r\n    // make the canvas\r\n    this.createCanvas();\r\n\r\n    // scroll listener added in createCanvas fn\r\n\r\n    // listen for resize\r\n    loop.addResizeFunction(this.onResize);\r\n  },\r\n  destroy: function () {\r\n    if (this.scrollController)\r\n      this.scrollController.destroy();\r\n    loop.removeFunction(this.onResize);\r\n    this.canvas.remove();\r\n    delete this;\r\n  },\r\n  anim: function (startPerc, endPerc, time, ease, cb) {\r\n    // first, turn off scroll listening\r\n    if (this.scrollController)\r\n      this.scrollController.disable();\r\n    // establish defaults\r\n    startPerc = startPerc || 0;\r\n    endPerc = endPerc || 1;\r\n    time = time || 1000;\r\n    ease = ease || eases.easeInOut;\r\n    // get some base vars\r\n    var startTime = new Date().getTime();\r\n    var deltaPerc = endPerc - startPerc;\r\n    var _this = this;\r\n    var running = true;\r\n    // this goes in the loop\r\n    var animationFn = function () {\r\n      if (running) {\r\n        var now = new Date().getTime();\r\n        var deltaTime = (now - startTime) / time;\r\n        if (deltaTime < 1)\r\n          _this.draw(ease(startPerc,deltaPerc,deltaTime));\r\n        else {\r\n          running = false;\r\n          _this.draw(endPerc);\r\n          if (_this.scrollController)\r\n            _this.scrollController.enable();\r\n          // get back out of the loop\r\n          loop.removeFunction(animationFn);\r\n          if (cb)\r\n            cb();\r\n        }\r\n      }\r\n    }\r\n    loop.addFunction(animationFn);\r\n  },\r\n  animIn: function (time, cb) {\r\n    // animate the canvas from inEaseStart to current scroll pos\r\n    // check if we even need to\r\n    var endPerc = this.getPercentageFromScroll();\r\n    if (endPerc < this.settings.inEaseStart)\r\n      return false;\r\n\r\n    this.anim(this.settings.inEaseStart, endPerc, time, eases.easeOut, cb);\r\n  },\r\n  animOut: function (time, cb) {\r\n    // animate the canvas from inEaseStart to current scroll pos\r\n    // check if we even need to\r\n    var startPerc = this.getPercentageFromScroll();\r\n    if (startPerc < this.settings.inEaseStart)\r\n      return false;\r\n\r\n    this.anim(startPerc, this.settings.inEaseStart, time, eases.easeIn, cb);\r\n  }\r\n}\r\n\r\n// temp auto init\r\n// var htrEls = document.querySelectorAll('.halftone');\r\n// var htrs = [];\r\n// for (var i = 0, len = htrEls.length; i < len; i++) {\r\n//   htrs.push(new Halftone(htrEls[i], { fade: 12, fixed: false }));\r\n// }\r\n// window.htrs = htrs;\r\nmodule.exports = Halftone;\r\n","/**\n *  scripts.js\n *  This should include objects, which in turn include the lib files they need.\n *  This keeps us using a modular approach to dev while also only including the\n *  parts of the library we need.\n */\n// objects\nrequire('objects/article');\n"],"sourceRoot":"/source/"}